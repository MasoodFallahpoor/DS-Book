\فصل{آرایه و ماتریس}

\قسمت{مقدمه}

آرایه یکی از ساده‌ترین و در عین حال مهمترین داده‌ساختارها است. معمولا از این داده‌ساختار به عنوان زیربنای بسیاری از داده‌ساختارهای دیگر استفاده می‌شود. برای مثال یکی از روش‌های پیاده‌سازی داده‌ساختارهای صف و پشته استفاده از داده‌ساختار آرایه است.

در این فصل سوالاتی در مورد آرایه و و انواع ماتریس (که در واقع یک آرایه‌ی دو بعدی است) مطرح خواهد شد.

\قسمت{منابع مطالعاتی}
یکی از منابع مناسب برای مطالعه‌ی بیشتر در مورد آرایه و ماتریس فصل سوم {\cite{ebrahimi}} است. در فصل ذکر شده در مورد آرایه، ماتریس‌ پایین مثلثی، ماتریس‌ قطری و ماتریس اسپارس صحبت شده است. از دیگر منابع مناسب برای کسب اطلاعات بیشتر در مورد آرایه و ماتریس می‌توان به فصل دوم {\cite{horowitz}} اشاره کرد.

\قسمت{آرایه}

\سوال آرایه‌ی دوبعدی {$A$} با {$n$} سطر و {$n$} ستون دارای نقطه‌ی حائل\پانویس{{\lr{Saddle point}}} است اگر بتوان عنصری مانند {$A[i,j]$} یافت به طوری که این عنصر دارای مقدار کمینه در سطر {$i$} و مقدار بیشینه در ستون {$j$} باشد. الگوریتمی ارائه دهید که نقطه‌ی حائل را، در صورت وجود، بیابد. سپس مرتبه‌ی زمانی الگوریتم را به دست آورید.

\پاسخ

شبه کد یکی از روش‌های تعیین نقطه‌ی حائل در یک آرایه‌ی دو بعدی در الگوریتم {\eqref{ch2:alg:saddlePnt}} آورده شده است. اگر آرایه‌ی {$A$} دارای نقطه‌ی حائل باشد آنگاه شماره‌ی سطر و ستون نقطه‌ی حائل به عنوان خروجی برگشت داده می‌شود. در غیر اینصورت زوج مرتب {$(-1,-1)$} به معنی عدم وجود چنین نقطه‌ای بازگردانده خواهد شد.
\begin{algorithm}
\caption{یافتن نقطه‌ی حائل در یک آرایه‌ی دو بعدی}\label{ch2:alg:saddlePnt}
\begin{latin}
\begin{algorithmic}[1]
\Function{SaddlePoint}{$A$}
		\For{$i \gets 1 \To n$}
				\For{$j \gets 1 \To n$}
						\If{\bcall{MinInRow}{$A,i,j$} $\isequal \const{true}$}
								\If{\bcall{MaxInColumn}{$A,i,j$} $\isequal \const{true}$}
										\State	\Return $(i,j)$
								\EndIf
						\EndIf
				\EndFor
		\EndFor
		\State	\Return $(-1,-1)$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در الگوریتم {\eqref{ch2:alg:saddlePnt}} از دو زیربرنامه‌ی {\bcall{MinInRow}{}} و {\bcall{MaxInCol}{}} به ترتیب برای تعیین کمینه بودن مقدار عنصر {$A[i,j]$} در سطر {$i$} و تعیین بیشینه بودن مقدار {$A[i,j]$} در ستون {$j$} استفاده شده است. شبه کد این دو زیربرنامه به ترتیب در قالب الگوریتم‌های {\eqref{ch2:alg:minInRow}} و {\eqref{ch2:alg:maxInCol}} نشان داده شده است.

\begin{algorithm}
\caption{تعیین کمینه بودن عنصری خاص در یک سطر خاص}\label{ch2:alg:minInRow}
\begin{latin}
\begin{algorithmic}[1]
\Function{MinInRow}{$A,i,j$}
		\For{$k \gets 1 \To n$}
				\If{$A[i,k] < A[i,j]$}
						\State	\Return \const{false}
				\EndIf
		\EndFor
		\State	\Return \const{true}
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\begin{algorithm}
\caption{تعیین بیشینه بودن عنصری خاص در یک ستون خاص}\label{ch2:alg:maxInCol}
\begin{latin}
\begin{algorithmic}[1]
\Function{MaxInCol}{$A,i,j$}
		\For{$k \gets 1 \To n$}
				\If{$A[k,j] > A[i,j]$}
						\State	\Return \const{false}
				\EndIf
		\EndFor
		\State	\Return \const{true}
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

همانطور که مشخص است تعداد تکرار حلقه‌ی موجود در زیربرنامه‌ی {\bcall{MinInRow}{}} برابر با تعداد ستون‌های آرایه‌ی {$A$} است و چون در صورت سوال بیان شده است که آرایه‌ی {$A$} دارای {$n$} ستون است پس این زیربرنامه‌ی از مرتبه {$O(n)$} است. از طرف دیگر تعداد تکرار حلقه‌ی موجود در زیربرنامه‌ی {\bcall{MaxInCol}{}} برابر با تعداد سطرهای آرایه‌ی {$A$}، یعنی {$n$}، است و بدین ترتیب مرتبه‌ی زمانی این زیربرنامه نیز برابر با {$O(n)$} است.

با توجه به اینکه مرتبه‌ی زمانی هر دو زیربرنامه‌ی مورد استفاده در {\bcall{SaddlePoint}{}} را در اختیار داریم، می‌توان مرتبه‌ی زمانی الگوریتم {\eqref{ch2:alg:saddlePnt}} را به راحتی به دست آورد. در این الگوریتم دو حلقه‌ی تو در تو وجود دارد که در مجموع {$n^2$} بار اجرا می‌شوند و مرتبه‌ی زمانی هر بار اجرای حلقه‌ی داخلی برابر با {$O(n)$} است. بدین ترتیب الگوریتم {\bcall{SaddlePoint}{}} از مرتبه‌ی {$O(n^3)$} است.

\سوال داده‌‌ساختار {$D$} را در نظر بگیرید. این داده‌ساختار از یک آرایه‌ی دو بعدی با {$m$} سطر و {$n$} ستون تشکیل ‌شده است به طوری که در هر سطر، هر مقدار از مقدار بعدی خود بزرگتر و از مقدار قبلی خود کوچکتر است و همچنین در هر ستون هر مقدار از مقدار پایینی خود بزرگتر و از مقدار بالایی خود کوچکتر است. در خانه‌های خالی داده‌ساختار {$D$} مقدار {$-\infty$} قرار می‌گیرد. مثالی از چنین داده‌ساختاری در ادامه نشان داده شده است.  الگوریتمی برای حذف مقدار بیشینه و همچنین الگوریتمی برای درج مقداری جدید در داده‌ساختار {$D$} ارائه دهید.
$$
\begin{bmatrix}
22 & 19 & 18 & 15 & -\infty\\
20 & 18 & 16 & 14 & -\infty\\
13 & 12 & 9 & -\infty & -\infty\\
-\infty & -\infty & -\infty & -\infty & -\infty\\
-\infty & -\infty & -\infty & -\infty & -\infty
\end{bmatrix}
$$

\پاسخ

برای درج یک مقدار جدید در داده‌ساختار {$D$} ابتدا آن را در مکان {$D[m,n]$} قرار می‌دهیم و سپس با استفاده از زیربرنامه‌ی
{\bcall{Percolate}{}} سعی می‌کنیم مقدار تازه درج شده را به مکان مناسب انتقال دهیم تا همچنان ویژگی مرتب بودن داده‌ساختار حفظ شود. روش کار بدین صورت است که همواره مقدار تازه درج شده، با این فرض که در حال حاضر در مکان {$D[i,j]$} قرار دارد، را با دو مقدار {$D[i,j-1]$} و {$D[i-1,j]$} مقایسه کرده و با کوچکترین آن دو جابجا می‌کنیم. این روند را به همین ترتیب ادامه می‌دهیم تا به حالتی برسیم که مقدار تازه درج شده از هر دو مقدار {$D[i,j-1]$} و {$D[i-1,j]$} کوچکتر باشد. در چنین حالتی  مقدار تازه درج شده در مکان درست خود قرار دارد و اجرای زیربرنامه‌ی {\bcall{Percolate}{}} خاتمه می‌یابد.

الگوریتم {\eqref{ch2:alg:insert}} شبه کد عمل درج را نشان می‌دهد. در این الگوریتم {$D$} داده‌ساختاری است که قرار است مقدار {$v$} در آن درج شود.
\begin{algorithm}
\caption{درج یک مقدار جدید در داده‌ساختار {$D$}}\label{ch2:alg:insert}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{Insert}{$D,v$}
		\State	$D[m,n] \gets v$
		\State	\bcall{Percolate}{$D,m,n$}
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

شبه کد زیربرنامه‌ی {\bcall{Percolate}{}} در قالب الگوریتم {\eqref{ch2:alg:percolate}} آورده شده است.
\begin{algorithm}
\caption{جابجا کردن مقدار تازه درج شده به سمت چپ یا بالا}\label{ch2:alg:percolate}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{Percolate}{$D,i,j$}
		\State	$\id{min} \gets$ \bcall{Minimum}{$D[i,j],D[i,j-1],D[i-1,j]$}
		\If{$\id{min} \isequal D[i,j]$}
				\State	\Return
		\ElsIf{$\id{min} \isequal D[i,j-1]$}
				\State	\bcall{Swap}{$D[i,j],D[i,j-1]$}
				\State	\bcall{Percolate}{$D,i,j-1$}
		\Else
				\State	\bcall{Swap}{$D[i,j],D[i-1,j]$}
				\State	\bcall{Percolate}{$D,i-1,j$}
		\EndIf		
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

با توجه به مرتب بودن سطرها و ستون‌های داده‌ساختار {$D$} به صورت نزولی، می‌توان نتیجه گرفت که مقدار بیشینه در مکان {$D[1,1]$} قرار دارد. برای حذف مقدار بیشینه ابتدا مقدار خانه‌ی {$D[1,1]$} را در یک متغیر ذخیره می‌کنیم و سپس در مکان {$D[1,1]$} مقدار  {$-\infty$} را قرار می‌دهیم. سپس با استفاده از زیربرنامه‌ی {\bcall{SiftDown}{}} مقدار موجود در {$D[1,1]$} را تا زمانی به سمت پایین یا راست جابجا می‌کنیم که دوباره خاصیت مرتب بودن داده‌ساختار برقرار شود. شبه کد زیربرنامه‌ی حذف مقدار بیشینه در الگوریتم {\eqref{ch2:alg:delMax}} آمده است.
\begin{algorithm}
\caption{حذف مقدار بیشینه از داده‌ساختار {$D$}}\label{ch2:alg:delMax}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{DeleteMax}{$D$}
		\State	$\id{max} \gets D[1,1]$
		\State	$D[1,1] \gets -\infty$
		\State	\bcall{SiftDown}{$D,1,1$}
		\State	\Return $\id{max}$	
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

شبه کد زیربرنامه‌ی {\bcall{SiftDown}{}} در الگوریتم {\eqref{ch2:alg:siftDown}} نشان داده شده است.  روش کلی کار این زیربرنامه‌ مانند زیربرنامه‌ی {\bcall{Percolate}{}} است با این تفاوت که مقدار {$D[i,j]$} با مقادیر {$D[i,j+1]$} و {$D[i+1,j]$} مقایسه شده و به جای جابجایی به سمت بالا یا چپ، به سمت پایین یا راست جابجا می‌شود.
\begin{algorithm}
\caption{جابجا کردن مقدار {$-\infty$} به سمت راست یا پایین}\label{ch2:alg:siftDown}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{SiftDown}{$D,i,j$}
		\State	$\id{max} \gets$ \bcall{Maximum}{$D[i,j],D[i,j+1],D[i+1,j]$}
		\If{$\id{max} \isequal D[i,j]$}
				\State	\Return
		\ElsIf{$\id{max} \isequal D[i,j+1]$}
				\State	\bcall{Swap}{$D[i,j],D[i,j+1]$}
				\State	\bcall{SiftDown}{$D,i,j+1$	}
		\Else
				\State	\bcall{Swap}{$D[i,j],D[i+1,j]$}
				\State	\bcall{SiftDown}{$D,i+1,j$}
		\EndIf
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

توجه داشته باشید که در شبه کد زیربرنامه‌های {\bcall{Percolate}{}} و {\bcall{SiftDown}{}} به دلیل جلوگیری از شلوغ شدن شبه کد، از قرار دادن دستورات شرطی مربوط به چک کردن محدوده‌ی اندیس‌ها‌ی داده‌ساختار {$D$} خودداری شده است.

هر دو عمل درج و حذف از مرتبه‌ی {$O(m+n)$} هستند. اثبات این موضوع به خواننده واگذار می‌شود (راهنمایی: قرار دهید {$p=m+n$} و {$T(p)$} را به عنوان رابطه‌ی بازگشتی نشان دهنده‌ی زمان مصرفی عمل درج یا حذف در نظر بگیرید. سپس نشان دهید {$T(p)$} از مرتبه‌ی {$O(p)$} است).

\سوال آرایه‌ی‌ {$n$} خانه‌ای {$A$} یک آرایه‌ی‌ تک‌قُله‌ای\پانویس{{\lr{Single peak}}} است اگر مقداری مانند {$A[m]$} وجود داشته باشد به طوری که به ازای این مقدار هر دو شرط زیر برقرار باشند:
\شروع{فقرات}
\فقره برای هر {$i$}، {$1 \leqslant i < m$}، داشته باشیم {$A[i]<A[i+1]$}.
\فقره برای هر {$j$}، {$m\leqslant j \leqslant n$}، داشته باشیم {$A[j]>A[j+1]$}.
\پایان{فقرات}
در این صورت می‌توان گفت خانه‌ی {$A[m]$} قله‌ یا همان بزرگترین مقدار آرایه‌ی {$A$} است. در شکل {\eqref{ch2:fig:sngPeakArray}} یک آرایه‌ی تک‌قله‌ای نشان داده شده است و {$A[6]$} با مقدار ۱۶ قله‌ی این آرایه است. الگوریتمی بنویسید که یک آرایه‌ی تک‌قله‌ای را به عنوان ورودی دریافت کرده و قله‌ی آن را در زمان {$O(\lg n)$} به دست آورد. (راهنمایی: از ایده‌ی موجود در الگوریتم جستجوی دودویی استفاده کنید).

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-0.6117188)(8.04,0.65171874)
\psframe[linewidth=0.04,dimen=outer](8.04,0.18828125)(0.0,-0.6117188)
\psline[linewidth=0.04cm](0.98,0.14828125)(0.98,-0.57171875)
\psline[linewidth=0.04cm](1.98,0.14828125)(1.98,-0.57171875)
\psline[linewidth=0.04cm](2.98,0.14828125)(2.98,-0.57171875)
\psline[linewidth=0.04cm](3.98,0.14828125)(3.98,-0.57171875)
\psline[linewidth=0.04cm](5.0,0.14828125)(5.0,-0.57171875)
\psline[linewidth=0.04cm](6.0,0.14828125)(6.0,-0.57171875)
\psline[linewidth=0.04cm](7.0,0.14828125)(7.0,-0.57171875)
\usefont{T1}{ptm}{m}{n}
\rput(0.466875,0.47828126){$1$}
\rput(1.4785937,0.47828126){$2$}
\rput(2.4876564,0.47828126){$3$}
\rput(3.4809375,0.47828126){$4$}
\rput(4.469531,0.45828125){$5$}
\rput(5.4953127,0.45828125){$6$}
\rput(6.4753127,0.45828125){$7$}
\rput(7.46875,0.45828125){$8$}
\rput(0.50421876,-0.23671874){\large $-1$}
\rput(1.4828125,-0.21671875){\large $3$}
\rput(2.4989061,-0.23671874){\large $4$}
\rput(3.491875,-0.23671874){\large $9$}
\rput(4.4465623,-0.21671875){\large $14$}
\rput(5.465781,-0.21671875){\large $16$}
\rput(6.4559374,-0.23671874){\large $13$}
\rput(7.485,-0.23671874){\large $5$}
\end{pspicture} 
}
\caption{یک آرایه‌ی تک‌قله‌ای با قله‌ی {$A[6]$}}\label{ch2:fig:sngPeakArray}
\end{center}
\end{figure}

\پاسخ

با در نظر گرفتن تعریف آرایه‌ی تک‌قله‌ای، به ازای هر اندیس {$i$}، {$1 \leqslant i \leqslant n$}، یکی از دو رابطه‌ی {$A[i] < A[i+1]$} یا {$A[i]>A[i+1]$} برقرار است. با توجه به این دو حالت می‌توان گفت:
\شروع{فقرات}
\فقره اگر {$A[i]<A[i+1]$} آنگاه باید در محدوده‌ی {$A[i+1\twodots n]$} به دنبال قله بگردیم.
\فقره اگر {$A[i]>A[i+1]$} آنگاه باید در محدوده‌ی {$A[1\twodots i]$} به دنبال قله بگردیم.
\پایان{فقرات}
با توجه به توضیحات داده شده می‌توان از الگوریتم {\eqref{ch2:alg:findPeak}} برای پیدا کردن قله‌ی یک آرایه‌ی تک‌قله‌ای استفاده کرد.
\begin{algorithm}
\caption{یافتن قله در یک آرایه‌ی تک‌قله‌ای}\label{ch2:alg:findPeak}
\begin{latin}
\begin{algorithmic}[1]
\Function{FindPeak}{$A$}
		\State	$\id{start} \gets 1$
		\State	$\id{end} \gets \attrib{A}{length}$
		\While{$\id{start} < \id{end}$}
				\State	$\id{mid} \gets \lfloor(\id{start}+\id{end}) / 2\rfloor$
				\If{$A[\id{mid}] < A[\id{mid}+1]$}
						\State	$\id{start} \gets \id{mid}+1$
				\EndIf
				\If{$A[\id{mid}] > A[\id{mid}+1]$}
						\State	$\id{end} \gets \id{mid}$
				\EndIf
		\EndWhile
		\State	\Return $A[\id{start}]$	
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

همانطور که مشاهده می‌شود روش کار این الگوریتم شباهت زیادی به الگوریتم جستجوی دودویی دارد و با انجام تحلیلی مشابه تحلیل الگوریتم جستجوی دودویی می‌توان به این نتیجه رسید که الگوریتم {\bcall{FindPeak}{}}، همچون الگوریتم جستجوی دودویی، از مرتبه‌ی {$O(\lg n)$} است.

\سوال آرایه‌ی {$A$} که دارای زوج عنصر و حاوی اعداد غیر تکراری است  و همچنین عدد {$k$} را در اختیار داریم. می‌گوییم آرایه‌ی {$A$} از نوع
 {\lr{K-Flat}} است اگر به ازای هر {$A[i]$}، {$1\leqslant i\leqslant n$}، عنصری مانند {$A[j]$}، {$1\leqslant j\leqslant n$}، با شرط
 {$i \neq j$} یافت شود به طوری که {$A[i]+A[j]=k$}. برای مثال آرایه‌ی نشان داده شده در شکل {\eqref{ch2:fig:kflatarray}} را در نظر بگیرید. این آرایه به ازای {$k=11$} یک آرایه‌ی {\lr{K-Flat}} است زیرا داریم:
\begin{displaymath}
A[1]+A[3]=A[2]+A[4]=A[5]+A[6]=11
\end{displaymath}

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-0.6117188)(6.0,0.65171874)
\psframe[linewidth=0.04,dimen=outer](6.0,0.18828125)(0.0,-0.6117188)
\psline[linewidth=0.04cm](0.98,0.14828125)(0.98,-0.57171875)
\psline[linewidth=0.04cm](1.98,0.14828125)(1.98,-0.57171875)
\psline[linewidth=0.04cm](2.98,0.14828125)(2.98,-0.57171875)
\psline[linewidth=0.04cm](3.98,0.14828125)(3.98,-0.57171875)
\psline[linewidth=0.04cm](5.0,0.14828125)(5.0,-0.57171875)
\usefont{T1}{ptm}{m}{n}
\rput(0.466875,0.47828126){$1$}
\rput(1.4785937,0.47828126){$2$}
\rput(2.4876564,0.47828126){$3$}
\rput(3.4809375,0.47828126){$4$}
\rput(4.469531,0.45828125){$5$}
\rput(5.4953127,0.45828125){$6$}
\rput(0.471875,-0.23671874){\large $9$}
\rput(1.4920312,-0.23671874){\large $7$}
\rput(2.49625,-0.23671874){\large $2$}
\rput(3.4989061,-0.23671874){\large $4$}
\rput(4.4840627,-0.23671874){\large $8$}
\rput(5.5028124,-0.23671874){\large $3$}
\end{pspicture}
}
\caption{یک آرایه‌ی {\lr{K-Flat}}}\label{ch2:fig:kflatarray}
\end{center}
\end{figure}

با در نظر گرفتن توضیحات داده شده الگوریتمی بنویسید که یک آرایه شامل اعداد غیر تکراری و عدد {$k$} را دریافت کرده و مشخص کند که آیا آرایه‌ی ورودی {\lr{K-Flat}} است یا خیر.

\پاسخ

الگوریتم تعیین {\lr{K-Flat}} بودن یک آرایه‌ در قالب الگوریتم {\eqref{ch2:alg:kflat}} آمده است. 

\begin{algorithm}
\caption{تعیین {\lr{K-Flat}} بودن آرایه}\label{ch2:alg:kflat}
\begin{latin}
\begin{algorithmic}[1]
\Function{KFlat}{$A,k$}
		\State	\bcall{Sort}{A}
		\State 	$i \gets 1$
		\State 	$j \gets \attrib{A}{length}$
		\While{$i < j$}
				\If{$A[i]+A[j] \neq k$}
						\State	\Return \const{false}
				\Else
						\State	$i \gets i+1$
						\State	$j \gets j-1$
				\EndIf
		\EndWhile
		\State \Return \const{true}\label{ch2:alg:line:kflatLast}
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در این الگوریتم در ابتدا و به کمک الگوریتم {\bcall{Sort}{}} آرایه‌ی ورودی را به صورت صعودی و در زمان {$O(n\lg n)$} مرتب می‌کنیم. سپس با استفاده از متغیر {$i$} از ابتدا به سمت انتهای آرایه و با استفاده از متغیر {$j$} از انتها به سمت ابتدای آرایه‌ حرکت می‌کنیم. با مقایسه‌ی دو عنصر {$A[i]$} و {$A[j]$} ممکن است دو حالت روی دهد که عبارت‌اند از:
\شروع{شمارش}
\فقره {$A[i]+A[j]=k$}: در این حالت به ازای عنصر {$A[i]$}، عنصر {$A[j]$} یافته شده است (و بالعکس) و این یعنی تا بدین جا شرط
 {\lr{K-Flat}} بودن آرایه نقض نشده است و اجرای الگوریتم برای بررسی سایر خانه‌ها باید ادامه پیدا کند. برای ادامه‌ی اجرای الگوریتم به متغیر {$i$} یک واحد اضافه می‌شود تا به خانه‌ی بعدی و از متغیر {$j$} یک واحد کم می‌شود تا به خانه‌ی قبلی اشاره کند.
\فقره {$A[i]+A[j]\neq k$}: این حالت، خود به دو حالت دیگر تقسیم می‌شود:
\شروع{شمارش}
\فقره {$A[i]+A[j]>k$}: در این حالت به ازای {$A[i]$} نمی‌توان عنصری یافت به طوری که شرط {\lr{K-Flat}} بودن برقرار باشد. 
\فقره {$A[i]+A[j]<k$}: در این حالت به ازای {$A[j]$} نمی‌توان عنصری یافت به طوری که شرط {\lr{K-Flat}} بودن برقرار باشد. 
\پایان{شمارش}
به این ترتیب در این حالت یا به ازای {$A[i]$} و یا به ازای {$A[j]$} شرط {\lr{K-Flat}} بودن آرایه نقض می‌شود و در نتیجه مقدار {\const{false}} به معنی {\lr{K-Flat}} نبودن آرایه برگشت داده می‌شود و اجرای الگوریتم خاتمه می‌یابد.
\پایان{شمارش}

اگر اجرای الگوریتم به خط {\ref{ch2:alg:line:kflatLast}} برسد به این معنی است که شرط {\lr{K-Flat}} بودن برای تمام عناصر آرایه برقرار بوده است و در نتیجه مقدار {\const{true}} به نشانه‌ی {\lr{K-Flat}} بودن آرایه‌ی ورودی برگشت داده می‌شود.

\سوال فرض کنید {$A$} آرایه‌ای {$n$} عنصری و شامل اعداد صحیح است. الگوریتمی با مرتبه‌ی زمانی {$O(n\lg n)$} بنویسید که آرایه‌‌ی {$A$} و عدد صحیح {$k$} را دریافت و مشخص کند آیا دو عنصر متمایز مانند {$A[i]$} و {$A[j]$} می‌توان یافت به طوری که {$A[i]+A[j]=k$}.

\پاسخ

شبه کد الگوریتم خواسته شد در قالب الگوریتم {\eqref{ch2:alg:checkPair}} آورده شده است. روش کار این الگوریتم در ادامه توضیح داده می‌شود.

\begin{algorithm}
\caption{یافتن دو عنصر در یک آرایه با مجموع مشخص}\label{ch2:alg:checkPair}
\begin{latin}
\begin{algorithmic}[1]
\Function{CheckPair}{$A,k$}
		\State	\bcall{Sort}{A}
		\State 	$i \gets 1$
		\State 	$j \gets \attrib{A}{length}$
		\While{$i < j$}
				\If{$A[i]+A[j] \isequal k$}
					\State	\Return \const{true}
				\ElsIf{$A[i]+A[j] < k$}
					\State	$i \gets i+1$
				\Else
					\State	$j \gets j-1$
				\EndIf
		\EndWhile
		\State \Return \const{false}\label{ch2:alg:ln:chkPairLast}
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در الگوریتم {\bcall{CheckPair}{}} در مرحله‌ی اول به کمک الگوریتم {\bcall{Sort}{}} آرایه‌ی {$A$} را به صورت صعودی و در زمان
 {$O(n\lg n)$} مرتب می‌کنیم. سپس با استفاده از متغیر {$i$} از ابتدا به سمت انتها و با استفاده از متغیر {$j$} از انتها به سمت ابتدای آرایه‌ی {$A$}‌ حرکت می‌کنیم. با مقایسه‌ی دو عنصر {$A[i]$} و {$A[j]$} ممکن است یکی از سه حالت زیر روی دهد:
\شروع{شمارش}
\فقره {$A[i]+A[j]=k$}: در این حالت دو عنصر {$A[i]$} و {$A[j]$} پیدا شده‌اند به طوری که حاصل جمع آنها برابر با {$k$} است. در چنین حالتی مقدار {\const{true}} به عنوان خروجی الگوریتم و به نشانه‌ی اجرای موفقیت آمیز الگوریتم برگشت داده می‌شود.
\فقره {$A[i]+A[j]<k$}: در این حالت چون {$A[i]+A[j]$} کمتر از {$k$} است، با توجه به مرتب بودن آرایه‌ی {$A$} به صورت صعودی، یک واحد به مقدار {$i$} اضافه می‌شود تا در دور بعدی اجرای حلقه مقدار {$A[i]+A[j]$} به {$k$} نزدیکتر و در حالت ایده‌آل برابر با {$k$} شود.
\فقره {$A[i]+A[j]>k$}: در این حالت چون {$A[i]+A[j]$} بزرگتر از {$k$} است، با توجه به مرتب بودن آرایه‌ی {$A$} به صورت صعودی، یک واحد از مقدار {$j$} کم می‌شود تا در دور بعدی اجرای حلقه مقدار {$A[i]+A[j]$} به {$k$} نزدیکتر و در حالت ایده‌آل برابر با {$k$} شود.
\پایان{شمارش}
اگر اجرای الگوریتم به خط {\ref{ch2:alg:ln:chkPairLast}} برسد مقدار {\const{false}} به عنوان خروجی الگوریتم برگشت داده می‌شود تا نشان داده شود که هیچ دو عنصر متمایزی در آرایه‌ی {$A$} وجود ندارند به طوری که حاصل جمع آنها برابر با {$k$} شود.

\سوال فرض کنید {$A$} آرایه‌ای {$n$} عنصری ({$n\geqslant 2$}) و شامل اعداد صحیح در بازه‌ی {$[1,n-1]$} است. تمام اعداد موجود در آرایه‌ی {$A$} متمایز هستند به جز یک عدد که دو بار در آرایه ظاهر شده است. الگوریتمی کارا بنویسید که چنین آرایه‌ای را دریافت کرده و عدد تکراری را بازگرداند. مرتبه‌ی زمانی الگوریتم خود را به دست آورید.

\پاسخ

شبه کد الگوریتم یافتن عدد تکرار شده در یک آرایه در الگوریتم {\eqref{ch2:alg:fndRepeatedNo}} آورده شده است. 

\begin{algorithm}
\caption{یافتن عدد تکرار شده در یک آرایه}\label{ch2:alg:fndRepeatedNo}
\begin{latin}
\begin{algorithmic}[1]
\Function{FindRepeated}{$A$}	
	\State	$n\gets \attrib{A}{length}$
	\State	Let $B[1\twodots n-1]$ be a new array of type boolean	
	\For{$i\gets 1 \To n-1$}
		\State	$B[i]\gets \const{false}$
	\EndFor
	\For{$i\gets 1 \To n$}
		\If{$B[A[i]]\isequal \const{false}$}
			\State	$B[A[i]]\gets \const{true}$
		\Else
			\State	\Return $A[i]$
		\EndIf
	\EndFor	
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

روش کار این الگوریتم بسیار ساده است. در ابتدای کار آرایه‌ای از نوع منطقی به نام {$B$} و به طول {$n-1$} تعریف شده است و مقدار اولیه‌ی تمام خانه‌های آن برابر با {\const{false}} قرار داده شده است. سپس با استفاده از یک حلقه تمام خانه‌های آرایه‌ی {$A$} بررسی می‌شوند. در یک تکرار از حلقه یکی از دو حالت زیر روی می‌دهد:
\شروع{فقرات}
\فقره مقدار خانه‌ی {$B[A[i]]$} برابر با {\const{false}} باشد: این حالت بدین معنی است که عدد موجود در خانه‌ی {$A[i]$}، تا تکرار جاری در آرایه‌ی {$A$} مشاهده نشده است. در این حالت مقدار خانه‌ی {$B[A[i]]$} برابر با {\const{true}} قرار داده می‌شود تا نشان داده شود عدد موجود در خانه‌ی {$A[i]$} تا تکرار جاری یک بار مشاهده شده است.
\فقره مقدار خانه‌ی {$B[A[i]]$} برابر با {\const{true}} باشد: این حالت زمانی اتفاق می‌افتد که عدد موجود در خانه‌ی {$A[i]$} در یکی از تکرارهای قبلی حلقه مشاهده شده باشد و این یعنی عدد موجود در خانه‌ی {$A[i]$} همان عدد تکرار شده در آرایه‌ی {$A$} است. در این حالت عدد موجود در خانه‌ی {$A[i]$} به عنوان جواب الگوریتم برگشت داده می‌شود.
\پایان{فقرات}

الگوریتم {\bcall{FindRepeated}{}} در بدترین حالت از مرتبه‌ی {$\Theta (n)$} است زیرا حلقه‌ی اول همواره {$n-1$} بار و حلقه‌ی دوم حداکثر {$n$} بار اجرا می‌شود.

\سوال تابعی بازگشتی بنویسید که بزرگترین مقدار در یک آرایه را بیابد.

\پاسخ

الگوریتم {\eqref{ch2:alg:recFindMax}} نشان دهنده‌ی شبه کد تابع بازگشتی یافتن بزرگترین مقدار در یک آرایه است. برای یافتن بزرگترین مقدار در آرایه‌ی {$A$} تابع {\bcall{FindMax}{}} باید به صورت {\bcall{FindMax}{$A,1,\attrib{A}{length}$}} فراخوانی شود. در ادامه روش کار این تابع بیان می‌شود.

\begin{algorithm}
\caption{یافتن بزرگترین مقدار در یک آرایه به صورت بازگشتی}\label{ch2:alg:recFindMax}
\begin{latin}
\begin{algorithmic}[1]
\Function{FindMax}{$A,\id{low},\id{high}$}
	\If{$\id{low}\isequal\id{high}$}
		\State	$\id{max}\gets A[low]$
	\Else
		\State	$\id{max}\gets\bcall{FindMax}{A,low+1,high}$
		\If{$A[low] > \id{max}$}		
			\State	$\id{max}\gets A[low]$
		\EndIf
	\EndIf
	\State	\Return \id{max}	
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

اگر دو متغیر {\id{low}} و {\id{high}} برابر با یکدیگر باشند به این معنی است که زیرآرایه‌ی {$A[\id{low}\twodots\id{high}]$} دارای تنها یک خانه است و بدیهی است که مقدار همین تک خانه باید به عنوان بزرگترین مقدار زیرآرایه‌ی {$A[\id{low}\twodots\id{high}]$} بازگردانده شود.  در صورتی که زیرآرایه‌ی {$A[\id{low}\twodots\id{high}]$} دارای بیش از یک خانه باشد آنگاه ابتدا به صورت بازگشتی بزرگترین مقدار زیرآرایه‌ی {$A[\id{low+1}\twodots\id{high}]$} را به دست آورده و در متغیر {\id{max}} قرار می‌دهیم. سپس مقدار متغیر {\id{max}} را با خانه‌ی {$A[\id{low}]$} مقایسه می‌کنیم. اگر شرط {$A[low] > \id{max}$} برقرار باشد یعنی مقدار خانه‌ی {$A[low]$} همان بزرگترین مقدار زیرآرایه‌ی {$A[low\twodots\id{high}]$} است و مقدار متغیر {\id{max}} بروزرسانی می‌شود در غیر این صورت مقدار متغیر {\id{max}} بزرگترین مقدار آرایه است.

\سوال تابعی بازگشتی بنویسید که آرایه‌ی دو بعدی {$A$} با {$m$} سطر و {$n$} ستون را به عنوان ورودی دریافت کرده و مجموع مقادیر آن را به عنوان خروجی بازگرداند.

\پاسخ

شبه کد مربوط به تابع بازگشتی جمع مقادیر یک آرایه‌ی دو بعدی در قالب الگوریتم {\eqref{ch2:alg:sum2dArray}} نمایش داده شده است. برای جمع مقادیر آرایه‌ی دو بعدی {$A[1\twodots m,1\twodots n]$} تابع بازگشتی {\bcall{SumArray}{}} باید به صورت {\bcall{SumArray}{$A,1,1$}} فراخوانی شود.

\begin{algorithm}
\caption{جمع مقادیر یک آرایه‌ی دو بعدی به شکل بازگشتی}\label{ch2:alg:sum2dArray}
\begin{latin}
\begin{algorithmic}[1]
\Function{SumArray}{$A,i,j$}
	\If{$i\isequal m \And j \isequal n$}
		\State	\Return $A[i,j]$
	\ElsIf{$i\isequal m$}
		\State	$\id{sum} \gets 0$\label{ch2:alg:sum2dArray:ln:singleRowBegin}
		\For{$x\gets j \To n$}
			\State	$\id{sum} = \id{sum} + A[i,x]$
		\EndFor\label{ch2:alg:sum2dArray:ln:singleRowEnd}
	\ElsIf{$j\isequal n$}		
		\State	$\id{sum} \gets 0$\label{ch2:alg:sum2dArray:ln:singleColumnBegin}
		\For{$x\gets i \To m$}
			\State	$\id{sum} = \id{sum} + A[x,j]$
		\EndFor\label{ch2:alg:sum2dArray:ln:singleColumnEnd}
	\Else
		\State	$\id{sum} \gets 0$
		\For{$x\gets j \To n$}
			\State	$\id{sum} = \id{sum} + A[i,x]$
		\EndFor		
		\For{$x\gets i \To m$}
			\State	$\id{sum} = \id{sum} + A[x,j]$
		\EndFor
		\State	\Return	$\id{sum} + \bcall{SumArray}{A,i+1,j+1}$
	\EndIf
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در الگوریتم {\eqref{ch2:alg:sum2dArray}} سه حالت زیر به عنوان حالات پایه‌ی تابع بازگشتی در نظر گرفته شده‌اند:
\شروع{فقرات}
\فقره آرایه‌ی {$A$} دارای تنها یک خانه باشد. در این حالت مقدار همان تک خانه به عنوان جمع مقادیر آرایه بازگردانده می‌شود.
\فقره آرایه‌ی {$A$} دارای تنها یک سطر باشد. در این حالت با استفاده از یک حلقه، مقادیر آن تک سطر با یکدیگر جمع شده و به عنوان جمع مقادیر آرایه بازگردانده می‌شود (خطوط {\ref{ch2:alg:sum2dArray:ln:singleRowBegin}} تا {\ref{ch2:alg:sum2dArray:ln:singleRowEnd}}).
\فقره آرایه‌ی {$A$} دارای تنها یک ستون باشد. در چنین حالتی به کمک یک حلقه، مقادیر همان تک ستون با یکدیگر جمع شده و به عنوان جمع مقادیر آرایه برگردانده می‌شود (خطوط {\ref{ch2:alg:sum2dArray:ln:singleColumnBegin}} تا {\ref{ch2:alg:sum2dArray:ln:singleColumnEnd}}).
\پایان{فقرات}
اگر هیچ یک از حالات پایه‌ی تابع بازگشتی برقرار نباشند آنگاه می‌توان به صورت بازگشتی جمع مقادیر آرایه‌ی {$A$} را به دست آورد. برای این منظور ابتدا مقادیر سطر و ستون اول آرایه‌ی {$A$} را با یکدیگر جمع کرده و حاصل را در متغیر {\id{sum}} قرار می‌دهیم. با انجام این کار جمع مقادیر سطر و ستون اول ماتریس {$A$} را داریم و کافیست به صورت بازگشتی جمع مقادیر زیرآرایه‌ی {$A[2\twodots m,2\twodots n]$} را به دست آورده و مجموع به دست آمده را به متغیر {\id{sum}} اضافه کنیم تا جمع مقادیر آرایه‌ی {$A$} به دست آید.

\سوال آرایه‌ی‌ {$n$} عنصری {$A$} که حاوی اعداد صحیح است را در نظر بگیرید. زیرآرایه‌ی {$A[i\twodots j]$} یک زیرآرایه‌ی بیشینه\پانویس{{\lr{Maximum subarray}}} است اگر مجموع مقادیر این زیرآرایه از مجموع مقادیر هر زیرآرایه‌ی دیگری در {$A$} بزرگتر باشد. برای مثال در آرایه‌ی نشان داده شده در شکل {\eqref{ch2:fig:maxSubarray}} زیرآرایه‌ی {$A[8\twodots 11]$} با مجموع ۴۳ یک زیرآرایه‌ی بیشینه است. الگوریتمی از مرتبه‌ی {$O(n)$} ارائه دهید که زیرآرایه‌ی بیشینه‌ی یک آرایه‌ی یک بعدی را بیابد.

\پاسخ

الگوریتم {\eqref{ch2:alg:maxSubarray}} نشان دهنده‌‌ی شبه کد الگوریتم یافتن زیرآرایه‌ی بیشینه در یک آرایه‌ی یک بعدی است. این الگوریتم با عنوان الگوریتم کادان\پانویس{{\lr{Kadane's algorithm}}} شناخته می‌شود.

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-0.62875)(12.02,0.66875)
\psframe[linewidth=0.04,dimen=outer](12.02,0.17125)(0.0,-0.62875)
\psline[linewidth=0.04cm](1.0,0.13125)(1.0,-0.58875)
\psline[linewidth=0.04cm](2.0,0.13125)(2.0,-0.58875)
\psline[linewidth=0.04cm](3.0,0.13125)(3.0,-0.58875)
\psline[linewidth=0.04cm](4.0,0.13125)(4.0,-0.58875)
\psline[linewidth=0.04cm](5.02,0.13125)(5.02,-0.58875)
\psline[linewidth=0.04cm](6.0,0.13125)(6.0,-0.58875)
\psline[linewidth=0.04cm](7.0,0.13125)(7.0,-0.58875)
\psline[linewidth=0.04cm](8.0,0.13125)(8.0,-0.58875)
\psline[linewidth=0.04cm](9.0,0.13125)(9.0,-0.58875)
\psline[linewidth=0.04cm](10.0,0.13125)(10.0,-0.60875)
\psline[linewidth=0.04cm](11.02,0.13125)(11.02,-0.60875)
\usefont{T1}{ptm}{m}{n}
\rput(0.47734374,0.44625){$1$}
\rput(1.49625,0.44625){$2$}
\rput(2.5028124,0.44625){$3$}
\rput(3.4989061,0.44625){$4$}
\rput(4.485,0.46625){$5$}
\rput(5.512031,0.44625){$6$}
\rput(6.472031,0.44625){$7$}
\rput(7.4840627,0.44625){$8$}
\rput(8.491875,0.46625){$9$}
\rput(9.446406,0.44625){$10$}
\rput(10.467343,0.44625){$11$}
\rput(11.465157,0.44625){$12$}
\rput(0.4759375,-0.22671875){\large $13$}
\rput(1.4928125,-0.25375){\large $-3$}
\rput(2.4865625,-0.25375){\large $-25$}
\rput(3.5275,-0.22671875){\large $20$}
\rput(4.4928126,-0.25375){\large $-3$}
\rput(5.492656,-0.22671875){\large $-16$}
\rput(6.4828124,-0.22671875){\large $-23$}
\rput(7.4615626,-0.22671875){\large $18$}
\rput(8.4875,-0.22671875){\large $20$}
\rput(9.46125,-0.24671875){\large $-7$}
\rput(10.465157,-0.22671875){\large $12$}
\rput(11.436563,-0.27375){\large $-5$}
\end{pspicture}  
}\caption{آرایه‌ای با زیرآرایه‌ی بیشینه‌ی {$A[8\twodots 11]$}}\label{ch2:fig:maxSubarray}
\end{center}
\end{figure}

\begin{algorithm}
\caption{یافتن زیرآرایه‌ی بیشینه‌ در یک آرایه‌ی یک بعدی}\label{ch2:alg:maxSubarray}
\begin{latin}
\begin{algorithmic}[1]
\Function{MaxSubarray}{$A$}
	\State	$n\gets \attrib{A}{\id{length}}$
	\State	$\id{maxSum}\gets -\infty$
	\State	$\id{endingHereSum}\gets -\infty$
	\For{$j\gets 1 \To n$}
		\State	$\id{endingHereLow}\gets j$
		\If{$\id{endingHereSum} + A[j]> A[j]$}
			\State	$\id{endingHereSum}\gets \id{endingHereSum} + A[j]$
		\Else
			\State	$\id{endingHereLow}\gets j$
			\State	$\id{endingHereSum}\gets A[j]$
		\EndIf
		\If{$\id{endingHereSum} > \id{maxSum}$}
			\State	$\id{maxSum}\gets \id{endingHereSum}$
			\State	$\id{low}\gets \id{endingHereLow}$
			\State	$\id{high}\gets \id{endingHereHigh}$			
		\EndIf		
	\EndFor
	\State	\Return $(\id{low},\id{high},\id{maxSum})$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\سوال در مواقعی ممکن است در یک آرایه به جای یک مقدار خاص، به دنبال مقداری با یک \متن‌خوابیده{ویژگی} خاص باشیم. برای مثال در آرایه‌ای شامل تعدادی عدد به دنبال {$k$}امین بزرگترین عدد باشیم. یک روش برای بدست آوردن {$k$}امین بزرگترین مقدار این است که آرایه را به صورت نزولی مرتب کنیم که در این صورت می‌توان گفت {$k$}امین بزرگترین مقدار در مکان {$k$}ام آرایه قرار دارد. این روش در اکثر اوقات کاری بیش از آنچه که مورد نیاز است را انجام می‌دهد زیرا مقادیری که کوچکتر از {$k$}امین بزرگترین مقدار هستند اهمیتی ندارند. روش دیگر این است که بزرگترین مقدار موجود در آرایه را پیدا کرده و  آن را در خانه‌ی اول آرایه قرار دهیم. سپس به دنبال دومین بزرگترین مقدار بگردیم و آن را در خانه‌ی دوم آرایه قرار دهیم و به همین ترتیب همین روند را ادامه دهیم. اگر این کار را {$k$} بار تکرار کنیم آنگاه {$k$}امین بزرگترین مقدار در خانه‌ی {$k$}ام آرایه قرار خواهد گرفت. با در نظر گرفتن توضیحات داده ‌شده، شبه کد الگوریتم روش دوم را نوشته و مرتبه‌ی زمانی آن را به دست آورید.

\پاسخ

شبه کد الگوریتم یافتن {$k$}امین بزرگترین مقدار در یک آرایه در الگوریتم {\eqref{ch2:alg:kthLargest}} آمده است.

\begin{algorithm}
\caption{یافتن {$k$}امین بزرگترین مقدار در یک آرایه}\label{ch2:alg:kthLargest}
\begin{latin}
\begin{algorithmic}[1]
\Function{KthLargest}{$A,k$}
		\State	$n \gets \attrib{A}{length}$
		\For{$i \gets 1 \To k$}
				\State	$\id{maxIdx} \gets i $
				\For{$j \gets i+1 \To n$}
						\If{$A[j] > A[\id{maxIdx}]$}
								\State	$\id{maxIdx} \gets j$						
						\EndIf
				\EndFor
				\State	\bcall{Swap}{$A[i], A[\id{maxIdx}]$}
		\EndFor
		\State	\Return $A[k]$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در دور اول از اجرای حلقه‌ی بیرونی، حلقه‌ی درونی {$n-1$} بار اجرا می‌شود. در دور دوم از اجرای حلقه‌ی بیرونی، حلقه‌ی درونی {$n-2$} بار اجرا می‌شود و به همین ترتیب تا اجرای {$k$}ام حلقه‌ی بیرونی که به ازای آن حلقه‌ی درونی {$n-k$} بار اجرا می‌شود. بدین ترتیب اگر مجموع تعداد تکرار دو حلقه الگوریتم {\bcall{KthLargest}{}} را با {$S(n)$} نشان دهیم خواهیم داشت:
\begin{align*}
S(n)&=\sum_{i=1}^{k}{(n-i)}\\
	&=\sum_{i=1}^{k}{n} - \sum_{i=1}^{k}{i}\\
	&=nk-\frac{k(k+1)}{2}
\end{align*}
به این ترتیب می‌توان گفت الگوریتم یافتن {$k$}امین بزرگترین مقدار یک آرایه از مرتبه‌ی {$O(nk)$} است. برای حل این مسئله الگوریتمی با مرتبه‌ی زمانی بهتر نیز وجود دارد.

\سوال برای یافتن {$k$}امین بزرگترین مقدار در یک آرایه نیازی به تعیین مکان دقیق قرارگیری مقادیر کوچکتر یا بزرگتر از {$k$}امین بزرگترین مقدار   نداریم. تنها کافی است بدانیم که این مقادیر، بزرگتر یا کوچکتر از {$k$}امین بزرگترین مقدار هستند. برای یافتن {$k$}امین بزرگترین مقدار در یک آرایه می‌توان از الگوریتمی که در ادامه بیان می‌شود استفاده کرد.

در ابتدا به صورت تصادفی عنصری از آرایه را انتخاب می‌کنیم. با توجه به عنصر انتخاب شده می‌توان عناصر آرایه را به دو دسته افراز\پانویس{{\lr{partition}}} کرد:
\شروع{شمارش}
\فقره عناصری که بزرگتر از عنصر انتخاب‌ شده هستند.
\فقره عناصری که کوچکتر یا مساوی عنصر انتخاب شده هستند.
\پایان{شمارش}
اگر عناصر بزرگتر از عنصر انتخابی را به خانه‌‌های قبل از این عنصر و عناصر کوچکتر یا مساوی عنصر انتخابی را به خانه‌های بعد از این عنصر انتقال دهیم در نهایت عنصر انتخابی در خانه‌ای مانند {$p$} در آرایه قرار خواهد گرفت. قرار گرفتن عنصر انتخابی در خانه‌ی {$p$} به این معنی‌ است که این عنصر {$p$}امین بزرگترین مقدار آرایه است. اگر {$p=k$} آنگاه {$k$}امین بزرگترین مقدار پیدا شده است و اجرای الگوریتم خاتمه می‌یابد. در صورتیکه {$k$} کوچکتر از {$p$} باشد آنگاه باید به صورت بازگشتی در زیرآرایه‌ی {$A[1\twodots p-1]$} به دنبال {$k$}امین بزرگترین مقدار بگردیم. در صورتیکه {$k$} بزرگتر از {$p$} باشد باید به صورت بازگشتی در زیرآرایه‌ی {$A[p+1\twodots n]$} به دنبال {$k$}امین بزرگترین مقدار بگردیم و باید این نکته را در نظر بگیریم که باید به دنبال {$(k-p)$}امین بزرگترین مقدار باشیم زیرا مقادیر بزرگتر از {$p$}امین بزرگترین مقدار، که قبل از خانه‌ی {$p$} هستند را نادیده می‌گیریم. لذا در زیرآرایه‌ی سمت راست باید به دنبال {$(k-p)$}امین بزرگترین مقدار باشیم.

با در نظر گرفتن آنچه بیان شد، شبه کد الگوریتم شرح داده شده را بنویسید.

\پاسخ

شبه کد الگوریتم یافتن {$k$}امین بزرگترین مقدار در یک آرایه در الگوریتم {\eqref{ch2:alg:recurKthLargest}} نشان داده شده است. اگر قصد یافتن {$k$}امین بزرگترین مقدار در آرایه‌ی {$A[1\twodots n]$} را داشته باشیم این الگوریتم باید به شکل {\bcall{KthLargest}{$A,1,n,k$}} فراخوانی شود.

\begin{algorithm}
\caption{یافتن {$k$}امین بزرگترین مقدار در یک آرایه به شکل بازگشتی}\label{ch2:alg:recurKthLargest}
\begin{latin}
\begin{algorithmic}[1]
\Function{KthLargest}{$A,l,h,k$}
		\If{$l < h$}
				\State	$p \gets \bcall{Partition}{A,l,h}$
				\If{$p \isequal k$}
						\State	\Return	$A[p]$
				\ElsIf{$k < p$}
						\State	\Return \bcall{KthLargest}{$A,l,p-1,k$}
				\Else
						\State	\Return \bcall{KthLargest}{$A,p+1,h,k-p$}
				\EndIf
		\EndIf
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

زیربرنامه‌ی {\bcall{Partition}{}} مهمترین بخش الگوریتم یافتن {$k$}امین بزرگترین مقدار است. این زیربرنامه عنصر {$A[h]$} در محدوده‌ی {$A[l\twodots h]$} را به عنوان عنصر محور\پانویس{{\lr{pivot}}} انتخاب کرده و عناصر آرایه‌ی {$A[l\twodots h]$} را طوری جابجا می‌کند که عناصر بزرگتر از عنصر محور به قبل از عنصر محور و عناصر کوچکتر یا مساوی عنصر محور به بعد از آن منتقل شوند. سپس مکان نهایی قرارگیری عنصر محور را به عنوان خروجی باز می‌گرداند. شبه کد زیربرنامه‌ی {\bcall{Partition}{}} در قالب الگوریتم {\eqref{ch2:alg:partition}} آورده شده است.

\begin{algorithm}
\caption{افراز آرایه به دو بخش}\label{ch2:alg:partition}
\begin{latin}
\begin{algorithmic}[1]
\Function{Partition}{$A,l,h$}
		\State	$x \gets A[h]$
		\State	$i \gets l-1$
		\For{$j \gets l \To h-1$}
				\If{$A[j] > x$}
						\State	$i \gets i+1$
						\State	\bcall{Swap}{$A[i],A[j]$}
				\EndIf
		\EndFor
		\State	\bcall{Swap}{$A[i+1],A[r]$}
		\State	\Return $i+1$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

روش کار زیربرنامه‌ی {\bcall{Partition}{}} بسیار ساده است. در این زیربرنامه آرایه‌ی ورودی در هر لحظه به چهار زیرآرایه‌ی نشان داده شده در شکل {\eqref{ch2:fig:partition}} تقسیم می‌شود. این زیرآرایه‌ها عبارت‌اند از:
\شروع{فقرات}
\فقره زیرآرایه‌ی {$A[l\twodots i]$} حاوی مقادیر بزرگتر از عنصر محور،
\فقره زیرآرایه‌ی {$A[i+1\twodots j-1]$} حاوی مقادیر کوچکتر یا مساوی عنصر محور،
\فقره زیرآرایه‌ی {$A[j\twodots h-1]$} حاوی مقادیری که هنوز بررسی نشده‌اند،
\فقره زیرآرایه‌ی تک عنصری {$A[h]$} که همان عنصر محور است.
\پایان{فقرات}

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-1.125)(12.02,1.125)
\psframe[linewidth=0.04,dimen=outer](12.02,0.635)(0.0,-0.165)
\psline[linewidth=0.04cm](1.0,0.595)(1.0,-0.125)
\psline[linewidth=0.04cm](2.0,0.595)(2.0,-0.125)
\psline[linewidth=0.04cm](3.0,0.595)(3.0,-0.125)
\psline[linewidth=0.124cm](4.0,0.715)(4.0,-0.225)
\psline[linewidth=0.04cm](5.02,0.595)(5.02,-0.125)
\usefont{T1}{ptm}{m}{n}
\rput(0.5009375,0.885){$l$}
\rput(3.5403125,0.885){$i$}
\psline[linewidth=0.04cm](6.0,0.595)(6.0,-0.125)
\psline[linewidth=0.04cm](8.0,0.595)(8.0,-0.125)
\psline[linewidth=0.04cm](9.0,0.595)(9.0,-0.125)
\psline[linewidth=0.04cm](10.0,0.595)(10.0,-0.145)
\rput(7.52875,0.945){$j$}
\rput(11.527813,0.905){$h$}
\psline[linewidth=0.03cm]{cc-cc}(0.32,-0.545)(1.86,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(2.16,-0.545)(3.7,-0.545)
\psline[linewidth=0.03]{cc-cc}(1.84,-0.545)(2.02,-0.785)(2.18,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(0.18,-0.365)(0.34,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(3.84,-0.365)(3.68,-0.545)
\rput(2.0820312,-1.0492188){$>A[h]$}
\psline[linewidth=0.03cm]{cc-cc}(4.2996535,-0.545)(5.3958426,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(5.609386,-0.545)(6.705575,-0.545)
\psline[linewidth=0.03]{cc-cc}(5.3816066,-0.545)(5.5097322,-0.785)(5.623622,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(4.2,-0.365)(4.31389,-0.545)
\psline[linewidth=0.03cm]{cc-cc}(6.8052287,-0.365)(6.6913385,-0.545)
\rput(5.5020313,-1.0492188){$\leq A[h]$}
\psline[linewidth=0.124cm](7.02,0.715)(7.02,-0.225)
\psline[linewidth=0.124cm](11.0,0.715)(11.0,-0.225)
\end{pspicture} 
}\caption{زیرآرایه‌های ایجاد شده توسط زیربرنامه‌ی {\lr{\textsc{Partition}}} }\label{ch2:fig:partition}
\end{center}
\end{figure}
در پایان اجرای زیربرنامه‌ی {\bcall{Partition}{}} اگر فرض کنیم عنصر محور در خانه‌ای با اندیس {$p$} قرار گرفته باشد آنگاه {$A[p]$} کوچکتر از تمام عناصر زیرآرایه‌ی {$A[l\twodots p-1]$} و بزرگتر یا مساوی عناصر {$A[p+1\twodots h]$} است.

\سوال آرایه‌ی {$n$} عنصری {$A$} که حاوی اعداد متمایز است را در نظر بگیرید. اگر {$i<j$} و {$A[i]>A[j]$} آنگاه زوج مرتب {$(i,j)$} یک وارونگی\پانویس{{\lr{inversion}}} نامیده می‌شود. برای مثال آرایه‌ی نشان داده شده در شکل {\eqref{ch2:fig:invarray}} دارای پنج وارونگی است که عبارت‌اند از:
\begin{displaymath}
I=\lbrace (2,1),(3,1)(8,1),(6,1),(8,6)\rbrace
\end{displaymath}

حداکثر تعداد وارونگی‌ها در یک آرایه‌ی {$n$} عنصری چه تعداد است؟

\پاسخ

اگر آرایه به صورت نزولی مرتب باشد آنگاه دارای بیشترین تعداد وارونگی خواهیم بود. در چنین حالتی به ازای عنصر اول آرایه دارای {$n-1$} وارونگی، به ازای عنصر دوم دارای {$n-2$} وارونگی و به همین ترتیب تا عنصر یکی مانده به آخر آرایه که به ازای آن دارای تنها یک وارونگی خواهیم بود. به این ترتیب تعداد کل وارونگی‌ها به صورت زیر به دست می‌آید:
\begin{displaymath}
I(n)=\sum_{i=1}^{n-1}{i}=\frac{n(n-1)}{2}=\binom{n}{2}
\end{displaymath}

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-0.6117188)(6.0,0.65171874)
\psframe[linewidth=0.04,dimen=outer](6.0,0.18828125)(0.0,-0.6117188)
\psline[linewidth=0.04cm](0.98,0.14828125)(0.98,-0.57171875)
\psline[linewidth=0.04cm](1.98,0.14828125)(1.98,-0.57171875)
\psline[linewidth=0.04cm](2.98,0.14828125)(2.98,-0.57171875)
\psline[linewidth=0.04cm](3.98,0.14828125)(3.98,-0.57171875)
\psline[linewidth=0.04cm](5.0,0.14828125)(5.0,-0.57171875)
\usefont{T1}{ptm}{m}{n}
\rput(0.466875,0.47828126){$1$}
\rput(1.4785937,0.47828126){$2$}
\rput(2.4876564,0.47828126){$3$}
\rput(3.4809375,0.47828126){$4$}
\rput(4.469531,0.45828125){$5$}
\rput(5.4953127,0.45828125){$6$}
\rput(0.51625,-0.23671874){\large $2$}
\rput(1.4828125,-0.23671874){\large $3$}
\rput(2.4840624,-0.23671874){\large $8$}
\rput(3.4920313,-0.23671874){\large $6$}
\rput(4.4773436,-0.23671874){\large $1$}
\rput(5.4396877,-0.23671874){\large $15$}
\end{pspicture} 
}
\caption{آرایه‌ای با پنج وارونگی}\label{ch2:fig:invarray}
\end{center}
\end{figure}

\سوال آرایه‌ی {$n$} عنصری {$A$} حاوی جایگشتی از اعداد ۱ تا {$n$} است. با {$n$} عدد متمایز می‌توان {$n!$} جایگشت مختلف تولید کرد. آرایه‌ی {$A$} می‌تواند حاوی هر یک از این جایگشت‌ها باشد و از قبل نمی‌دانیم کدام جایگشت در این آرایه قرار دارد. احتمال وجود هر یک از این جایگشت‌ها در آرایه‌ی {$A$} را مساوی فرض کنید. اگر الگوریتم {\eqref{ch2:alg:findMax}} بر روی آرایه‌ی {$A$} اجرا شود آنگاه دستور انتساب در خط {\ref{ch2:alg:line:asgmnt}} در این الگوریتم به طور میانگین چند بار اجرا می‌شود؟

\begin{algorithm}
\caption{یافتن بزرگترین مقدار در یک آرایه}\label{ch2:alg:findMax}
\begin{latin}
\begin{algorithmic}[1]
\Function{FindMax}{$A$}
		\State	$n\gets\attrib{A}{\id{length}}$
		\State	$\id{max}\gets -\infty$		
		\For{$i\gets 1 \To n$}
			\If{$A[i] > max$}
				\State	$\id{max}\gets A[i]$\label{ch2:alg:line:asgmnt}
			\EndIf
		\EndFor
		\State	\Return	$\id{max}$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\پاسخ

برای به دست آوردن میانگین تعداد دفعات اجرا شدن دستور انتساب در خط {\ref{ch2:alg:line:asgmnt}}، متغیر تصادفی {$X_i$} را به صورت زیر تعریف می‌کنیم:
\begin{displaymath}
X_i=
\begin{cases}
1\qquad\text{اگر عنصر {$i$}ام بزرگتر از {$i-1$} عنصر قبلی باشد}\\
0\qquad\text{اگر عنصر {$i$}ام بزرگتر از {$i-1$} عنصر قبلی نباشد}
\end{cases}
\end{displaymath}
به این ترتیب می‌توان متغیر تصادفی {$X$} را برابر با تعداد دفعات اجرای دستور انتساب در نظر گرفت و آن را به صورت زیر تعریف کرد:
\begin{displaymath}
X=X_1+X_2+\cdots + X_n=\sum_{i=1}^{n}{X_i}
\end{displaymath}

با به دست آوردن {\lr{E$[X]$}} یا همان امید ریاضی متغیر تصادفی {$X$} در واقع میانگین تعداد دفعات اجرای دستور انتساب را به دست خواهیم آورد. برای به دست آوردن {\lr{E$[X]$}} داریم:
\begin{align}
\mathrm{E}[X]&=\mathrm{E}\left(\sum_{i=1}^{n}{X_i}\right)\nonumber\\
	&=\sum_{i=1}^{n}{\mathrm{E}[X_i]}\label{ch2:eqn:EofX}
\end{align}
پس برای به دست آوردن {\lr{E$[X]$}} باید مقدار {\lr{E$[X_i]$}} را به دست آوریم. {\lr{E$[X_i]$}} برابر با احتمال این رویداد است که عنصر {$i$}ام بزرگتر از {$i-1$} عنصر قبلی خود باشد. یعنی 
\begin{displaymath}
\mathrm{E}[X_i]=\mathrm{P}(\text{عنصر {$i$}ام بزرگتر از {$i-1$} عنصر قبلی باشد})
\end{displaymath}
چون هر یک از {$i$} عنصر ابتدایی آرایه با احتمال یکسان ممکن است بزرگترین عنصر در بین این {$i$} عنصر باشد در نتیجه احتمال اینکه {$i$}امین عنصر بزرگتر از {$i-1$} عنصر قبلی خود باشد برابر با {$1/i$} است و این یعنی {$\mathrm{E}[X_i]=1/i$}. با جایگذاری {$1/i$} در رابطه‌ی {\eqref{ch2:eqn:EofX}} خواهیم داشت:
\begin{align*}
\mathrm{E}[X]&=\sum_{i=1}^{n}{\frac{\ 1\ }{i}}\\
	&\approx\lg n
\end{align*}
به این ترتیب نشان دادیم دستور انتساب موجود در خط {\ref{ch2:alg:line:asgmnt}} الگوریتم {\bcall{FindMax}{}} به طور میانگین {$\lg n$} بار اجرا می‌شود.

\سوال الگوریتمی بازگشتی بنویسید که آرایه‌ای شامل اعداد صحیح را به عنوان ورودی دریافت کرده و با کمترین تعداد مقایسات، مقادیر بیشینه و کمینه‌ی آرایه‌‌ی ورودی را به عنوان خروجی بازگرداند.

\پاسخ

الگوریتم {\eqref{ch2:alg:minMax}} نشان دهنده‌ی شبه کد الگوریتمی کارا برای یافتن مقادیر بیشینه و کمینه‌ در یک آرایه به صورت همزمان است. برای یافتن مقادیر بیشینه و کمینه‌ی آرایه‌ی {$A$} این الگوریتم باید به صورت {\bcall{MinMax}{$A,1,\attrib{A}{\id{length}}$}} فراخوانی شود. روش کار این الگوریتم در ادامه بیان شده است.

اگر آرایه‌ی ورودی دارای تنها یک عنصر باشد آنگاه شرط خط {\ref{ch2:alg:ln:1stBaseCase}} برقرار بوده و در نتیجه مقدار همین تک عنصر به عنوان مقدار بیشینه و کمینه‌ی آرایه بازگردانده می‌شود و اجرای الگوریتم خاتمه می‌یابد. در صورتی که شرط خط {\ref{ch2:alg:ln:2ndBaseCase}} برقرار باشد به این معنی است که آرایه دارای دو عنصر است و می‌توان با انجام یک مقایسه مقدار بزرگتر را در متغیر {\id{max}} و مقدار کوچکتر را در متغیر {\id{min}} قرار داد و به اجرای الگوریتم خاتمه داد. زمانی که آرایه دارای بیش از دو عنصر باشد با نادیده گرفتن دو عنصر ابتدایی زیرآرایه‌ی {$A[\id{low}\twodots\id{high}]$}، مقادیر بیشینه و کمینه‌ی زیرآرایه‌ی {$A[\id{low}+2\twodots\id{high}]$} را به دست می‌آوریم و مقدار کمینه را در متغیر {\lr{\id{min1}}} و مقدار بیشینه را در {\lr{\id{max1}}} قرار می‌دهیم. در نهایت با انجام سه مقایسه مقادیر بیشینه و کمینه‌ی کل آرایه را به دست آورده و برگشت می‌دهیم.

\begin{algorithm}
\caption{یافتن مقادیر بیشینه و کمینه‌ی یک آرایه به صورت همزمان}\label{ch2:alg:minMax}
\begin{latin}
\begin{algorithmic}[1]
\Function{MinMax}{$A,\id{low},\id{high}$}
	\If{$\id{low}\isequal \id{high}$}\label{ch2:alg:ln:1stBaseCase}
		\State	$\id{min}\gets A[\id{low}]$
		\State	$\id{max}\gets A[\id{low}]$		
	\ElsIf{$\id{low} + 1 \isequal \id{high}$}\label{ch2:alg:ln:2ndBaseCase}
		\If{$A[\id{low}] < A[\id{high}]$}
			\State	$\id{min}\gets A[\id{low}]$
			\State	$\id{max}\gets A[\id{high}]$		
		\Else
			\State	$\id{min}\gets A[\id{high}]$
			\State	$\id{max}\gets A[\id{low}]$				
		\EndIf
	\Else		
		\State	$\id{min1},\id{max1}\gets \bcall{MinMax}{A,\id{low}+2,\id{high}}$
		\If{$A[\id{low}] < A[\id{low}+1]$}
			\State	$\id{min}\gets A[\id{low}]$
			\State	$\id{max}\gets A[\id{low}+1]$		
		\Else
			\State	$\id{min}\gets A[\id{low}+1]$
			\State	$\id{max}\gets A[\id{low}]$				
		\EndIf
		\If{$\id{min1} < \id{min}$}
			\State	$\id{min}\gets \id{min1}$
		\EndIf
		\If{$\id{max1} > \id{max}$}
			\State	$\id{max}\gets \id{max1}$
		\EndIf		
	\EndIf
	\State	\Return	$(\id{min},\id{max})$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\قسمت{ماتریس اسپارس}

\سوال آیا حاصل ضرب دو ماتریس اسپارس لزوماً یک ماتریس اسپارس خواهد بود؟ اگر جواب مثبت است اثبات کنید و اگر جواب منفی است یک مثال نقض ارائه دهید.

\پاسخ

حاصل ضرب دو ماتریس اسپارس لزوماً یک ماتریس اسپارس نخواهد بود. به بیان دیگر ممکن است ماتریس حاصل شده از ضرب دو ماتریس اسپارس، ماتریسی باشد که حتی یک درایه با مقدار صفر هم ندارد. برای مثال به ضرب دو ماتریس زیر دقت کنید.
$$
\begin{bmatrix}
1 & 0 & 0 & 0\\
1 & 0 & 0 & 0\\
1 & 0 & 0 & 0\\
1 & 0 & 0 & 0
\end{bmatrix}
\begin{bmatrix}
1 & 1 & 1 & 1\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1\\
1 & 1 & 1 & 1\\
\end{bmatrix}
$$
ماتریس‌های ضرب شونده هر دو اسپارس هستند اما ماتریس حاصل ضرب یک ماتریس اسپارس نیست.

%\begin{mdframed}
قبل از پاسخ دادن به سوالات ۱۶ و ۱۷ قسمت زیر را بخوانید.

اگر از درایه‌های غیر صفر یک ماتریس اسپارس به عنوان درایه‌های مفید یاد کنیم آنگاه می‌توان گفت یک ماتریس اسپارس دارای درایه‌های مفید کمی است. اگر از یک آرایه‌ی دو بعدی برای ذخیره‌ی یک ماتریس اسپارس استفاده کنیم بسیاری از خانه‌های این آرایه حاوی مقادیر غیر مفید (صفر) خواهد بود. به منظور جلوگیری از مصرف بیهوده‌ی حافظه و عدم ذخیره‌ی مقادیر غیر مفید، به جای استفاده از یک آرایه‌ی دو بعدی از داده‌ساختاری که شرح آن در ادامه آمده است استفاده می‌شود.

ماتریس اسپارس {$M$} با {$m$} سطر و {$n$} ستون که دارای {$t$} درایه‌ی غیر صفر است را در نظر بگیرید. داده‌ساختاری که از آن برای برای ذخیره‌ی ماتریس اسپارس {$M$} استفاده می‌شود یک آرایه‌ی دو بعدی با تعریف {$A[0\twodots t,1\twodots 3]$} است. در خانه‌ی {$A[0,1]$} تعداد درایه‌های غیر صفر، در خانه‌ی {$A[0,2]$} تعداد سطرها و در خانه‌ی {$A[0,3]$} تعداد ستون‌های ماتریس {$M$} قرار می‌گیرد. اگر درایه‌های غیر صفر ماتریس {$M$} را به صورت سطر به سطر و از چپ به راست از یک تا {$t$} شماره‌گذاری کنیم آنگاه برای پر کردن سایر سطرهای این داده‌ساختار به این صورت عمل می‌کنیم که شماره‌ی سطر درایه‌ی غیر صفر {$i$}ام در خانه‌ی {$A[i,1]$}، شماره‌ی ستون این درایه در خانه‌ی {$A[i,2]$} و مقدار درایه در خانه‌ی {$A[i,3]$} ذخیره می‌شود. برای مثال اگر ماتریس اسپارس {$M$} به صورت زیر باشد آنگاه داده‌ساختار متناظر با این ماتریس به صورت نشان داده شده در شکل {\eqref{ch2:fig:sparseMat}} خواهد بود. در ادامه‌ی این فصل برای اشاره به داده‌ساختار شرح داده شده از عنوان {\lr{SparseMat}} استفاده خواهد شد.

$$
M=
\begin{bmatrix}
-1 & 0 & 3 & 0 & 0\\
0 & 5 & 0 & 0 & 6\\
1 & 0 & 0 & 3 & 0\\
0 & 0 & 0 & 6 & 0\\
0 & 0 & 4 & 0 & 0
\end{bmatrix}
$$
%\end{mdframed}

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-3.8417187)(3.5065625,3.8817186)
\psframe[linewidth=0.04,dimen=outer](3.4865625,3.3982813)(0.4465625,-3.8417187)
\psline[linewidth=0.04,fillstyle=solid,fillcolor=black](1.4665625,3.3582811)(1.4665625,-3.8217187)
\psline[linewidth=0.04cm](0.4665625,2.5982811)(3.4665625,2.5982811)
\psline[linewidth=0.04cm](0.4665625,1.7782812)(3.4665625,1.7782812)
\psline[linewidth=0.04cm](0.4665625,0.97828126)(3.4665625,0.97828126)
\psline[linewidth=0.04cm](0.4865625,0.17828125)(3.4865625,0.17828125)
\psline[linewidth=0.04cm](0.4665625,-0.6017187)(3.4665625,-0.6017187)
\psline[linewidth=0.04cm](0.4665625,-1.4017187)(3.4665625,-1.4017187)
\psline[linewidth=0.04cm](0.4665625,-2.1817188)(3.4665625,-2.1817188)
\psline[linewidth=0.04cm](0.4665625,-3.0017188)(3.4665625,-3.0017188)
\psline[linewidth=0.04,fillstyle=solid,fillcolor=black](2.4665625,3.3782814)(2.4665625,-3.8017187)
\usefont{T1}{ptm}{m}{n}
% columns' indicies
\rput(0.9734375,3.6882813){$1$}
\rput(1.9851563,3.7082813){$2$}
\rput(2.9742188,3.6882813){$3$}
% rows' indicies
\rput(0.14359374,2.9482813){$0$}
\rput(0.1134375,2.1682813){$1$}
\rput(0.12515625,1.3482813){$2$}
\rput(0.11421875,0.54828125){$3$}
\rput(0.1075,-0.25171876){$4$}
\rput(0.09609375,-1.0517187){$5$}
\rput(0.081875,-1.8317188){$6$}
\rput(0.0796875,-2.6517189){$7$}
\rput(0.0953125,-3.4717188){$8$}
% rows' values
\rput(0.9715625,2.9532812){\large $5$}
\rput(1.9715625,2.9532812){\large $5$}
\rput(2.950625,2.9732811){\large $8$}
\rput(0.94390625,2.1732812){\large $1$}
\rput(1.9439063,2.1732812){\large $1$}
\rput(2.8907812,2.1732812){\large $-1$}
\rput(0.9639062,1.3932812){\large $1$}
\rput(1.949375,1.3932812){\large $3$}
\rput(2.929375,1.3732812){\large $3$}
\rput(0.9628125,0.55328125){\large $2$}
\rput(1.9428124,0.55328125){\large $2$}
\rput(2.9315624,0.55328125){\large $5$}
\rput(0.9428125,-0.24671875){\large $2$}
\rput(1.9115624,-0.24671875){\large $5$}
\rput(2.9185936,-0.24671875){\large $6$}
\rput(0.949375,-1.0267187){\large $3$}
\rput(1.9039062,-1.0267187){\large $1$}
\rput(2.9039063,-1.0267187){\large $1$}
\rput(0.969375,-1.8267188){\large $3$}
\rput(1.9654688,-1.8267188){\large $4$}
\rput(2.949375,-1.8267188){\large $3$}
\rput(0.98546875,-2.6267188){\large $4$}
\rput(1.9654688,-2.6267188){\large $4$}
\rput(2.9585938,-2.6267188){\large $6$}
\rput(0.9715625,-3.4067187){\large $5$}
\rput(1.969375,-3.4067187){\large $3$}
\rput(2.9654686,-3.3867188){\large $4$}
\end{pspicture} 
}\caption{ماتریس اسپارس {$M$} که در داده‌ساختار {\lr{SparseMat}} ذخیره شده است.}\label{ch2:fig:sparseMat}
\end{center}
\end{figure}

\سوال ماتریس اسپارس {$M$} را در نظر بگیرید. اگر از داده‌ساختار {\lr{SparseMat}} برای ذخیره‌ی ماتریس {$M$} استفاده کنیم آنگاه مرتبه‌ی زمانی دسترسی به درایه‌ی {$m_{ij}$} چقدر است؟

\پاسخ

\سوال الگوریتمی ارائه دهید که ماتریس اسپارس {$M$}، ذخیره شده در داده‌ساختاری از نوع {\lr{SparseMat}}، را به عنوان ورودی دریافت کرده و ترانهاده‌ی آن را در زمان {$O(n+t)$} به دست آورد که در آن {$t$} بیانگر تعداد عناصر غیر صفر ماتریس اسپارس {$M$} و {$n$} نشان‌دهنده‌ی تعداد ستونهای ماتریس {$M$} است.

\پاسخ

شبه کد الگوریتم ترانهاده در الگوریتم {\eqref{ch2:alg:fastTran}} نشان داده شده است. ورودی این الگوریتم ماتریس اسپارس {$M$} است که در داده‌ساختاری از نوع {\lr{SparseMat}} ذخیره شده است و خروجی الگوریتم ماتریس {$T$} است که حاوی ترانهاده‌ی ماتریس {$M$} است.
\begin{algorithm}
\caption{ترانهاده‌‌ی سریع}\label{ch2:alg:fastTran}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{FastTranspose}{$M$}
		\State	let $T$ be a data structure of type SparseMat
		\State	let $C[1\twodots n]$ be a new array of type integer
		\State	$n \gets M[0,2]$
 		\State	$t \gets M[0,3]$
		\State	$T[0,1] \gets n$
		\State 	$T[0,2] \gets M[0,1]$
		\State	$T[0,3] \gets t$
		\If{$t \isequal 0$}
				\State	\Return
		\Else							
				\For{$i \gets 1 \To n$}
						\State	$C[i] \gets 0$
				\EndFor
				\For{$i \gets 1 \To t$}
						\State	$C[M[i,2]] \gets C[M[i,2]]+1$		
				\EndFor	
				\For{$i \gets 2 \To n$}
						\State	$C[i] \gets C[i-1]+C[i]$		
				\EndFor	
				\For{$i \gets 1 \To t$}
						\State	$j \gets C[M[i,2]]$		
						\State	$T[j,1] \gets M[i,2]$
						\State	$T[j,2] \gets M[i,1]$
						\State	$T[j,3] \gets M[i,3]$
						\State	$C[M[i,2]] \gets j+1$
				\EndFor		
		\EndIf
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

ایده‌ی مورد استفاده در الگوریتم {\eqref{ch2:alg:fastTran}} مانند ایده‌ی مورد استفاده در الگوریتم مرتب‌سازی شمارشی\پانویس{{\lr{Counting sort}}} است. حلقه‌ی اول به تمام عناصر آرایه‌ی {$C$} مقدار صفر را نسبت می‌دهد. سپس حلقه‌ی دوم تعداد عناصر غیر صفر در هر ستون ماتریس اسپارس را به دست می‌آورد به طوری که پس از پایان این حلقه، {$C[i]$} بیانگر تعداد عناصر غیر صفر ستون {$i$}ام ماتریس اسپارس است. پس از پایان حلقه‌ی سوم، {$C[i]$} بیانگر مجموع تعداد عناصر غیر صفر در ستون‌های ۱ تا {$i$} ماتریس اسپارس است. در نهایت حلقه‌ی چهارم کار ترانهاده کردن را انجام داده و هر یک از عناصر ماتریس {$M$} را در مکان مناسب از ماتریس {$T$} قرار می‌دهد. به این ترتیب در انتهای اجرای این الگوریتم ماتریس {$T$} حاوی ترانهاده‌ی ماتریس {$M$} خواهد بود.

برای محاسبه‌ی مرتبه‌ی زمانی الگوریتم {\bcall{FastTranspose}{}} می‌توان گفت حلقه‌های اول و سوم از مرتبه‌ی {$O(n)$} و حلقه‌های دوم و چهارم از مرتبه‌ی {$O(t)$} هستند. در نتیجه مرتبه‌ی زمانی الگوریتم {\bcall{FastTranspose}{}} برابر با {$O(n+t)$} است.

\قسمت{ماتریس‌های خاص}

\سوال فرض کنید {$A$} و {$B$} دو ماتریس پایین مثلثی با {$n$} سطر و {$n$} ستون هستند. تعداد کل مقادیر غیر صفر این دو ماتریس در مجموع برابر با {$n(n+1)$} است (ماتریس {$A$} دارای {$n(n+1)/2$} مقادیر غیر صفر و ماتریس {$B$} نیز دارای همین تعداد مقادیر غیر صفر است). با در اختیار داشتن ماتریس {$C$} با {$n$} سطر و  {$n+1$} ستون روشی ارائه دهید که بتوان مقادیر غیر صفر دو ماتریس {$A$} و {$B$} را به طور همزمان در ماتریس {$C$} ذخیره کرد.

\پاسخ

برای ذخیره‌سازی همزمان مقادیر غیر صفر دو ماتریس پایین مثلثی {$A$} و {$B$} در ماتریس {$C$}، کافیست مقادیر غیر صفر ماتریس {$A$} را به صورت پایین مثلثی و ترانهاده‌ی مقادیر غیر صفر ماتریس {$B$} را به صورت بالا مثلثی در ماتریس {$C$} ذخیره کنیم. برای درک بهتر نحوه‌ی ذخیره‌سازی به مثالی که در ادامه آمده است توجه کنید.
\begin{displaymath}
A=
\begin{bmatrix}
1 & 0 & 0 \\
2 & 3 & 0 \\
4 & 5 & 6
\end{bmatrix},
B=
\begin{bmatrix}
a & 0 & 0 \\
b & c & 0 \\
d & e & f
\end{bmatrix}
\Rightarrow C=
\begin{bmatrix}
1 & a & b & d \\
2 & 3 & c & e \\
4 & 5 & 6 & f
\end{bmatrix}
\end{displaymath}
با در نظر گرفتن این روش ذخیره‌سازی می‌توان فرمولی ارائه داد که به کمک آن بتوان بازیابی مقادیر از ماتریس {$C$} را به درستی انجام داد. با توجه به اینکه ماتریس {$A$} بدون هیچ تغییری در ماتریس {$C$} ذخیره شده است پس برای دسترسی به درایه‌ی {$A[i,j]$} می‌توان مقدار {$C[i,j]$} را بازیابی کرد. برای بازیابی {$B[i,j]$} نیز می‌توان مقدار {$C[j,i+1]$} را بازیابی کرد.

\سوال به ماتریس‌های مربعی که بر روی قطر اصلی و همچنین چند قطر بالا و پایین قطر اصلی دارای مقادیر غیر صفر هستند، ماتریس‌های نواری گفته می‌شود. ماتریس‌های نواری نوع خاصی از ماتریس‌های اسپارس به شمار می‌آیند. در زیر نمونه‌ای از یک ماتریس سه نواری نمایش داده شده است. حالت کلی یک ماتریس‌ {$a$} نواری به این صورت است که {$a-1$} قطر بالای قطر اصلی و {$a-1$} قطر پایین قطر اصلی و خود قطر اصلی دارای مقادیر غیر صفر هستند. 
$$
\begin{bmatrix}
1 & 3 & 8 & 0 & 0 & 0\\
5 & 2 & 1 & 1 & 0 & 0\\
9 & 1 & 6 & 8 & 7 & 0\\
0 & 6 & 1 & 1 & 4 & 2\\
0 & 0 & 7 & 3 & 4 & 9\\
0 & 0 & 0 & 2 & 3 & 1
\end{bmatrix}
$$

با در نظر گرفتن توضیحات داده شده به موارد زیر پاسخ دهید.
\شروع{شمارش}[A.]
\فقره در یک ماتریس {$a$} نواری که دارای {$n$} سطر و {$n$} ستون است چه تعداد عنصر غیر صفر وجود دارد؟
\فقره برای اینکه درایه‌ای مانند {$M[i,j]$} از ماتریس {$a$} نواری {$M$} حاوی مقدار غیر صفر باشد، چه رابطه‌ای باید میان اندیس‌های {$i$} و {$j$} برقرار باشد؟ 
\فقره یکی از روشهای ذخیره‌سازی یک ماتریس {$a$} نواری استفاده از یک آرایه یک بعدی مانند {$B$} است که در آن ابتدا بالاترین قطر، سپس قطر زیر آن و به همین ترتیب تا پایین‌ترین قطر ذخیره می‌شوند. فرمولی ارائه دهید که به کمک آن بتوان تعیین کرد عنصری غیر صفر از ماتریس {$M$} مانند {$M[i,j]$} در کدام خانه از آرایه‌ی {$B$} قرار می‌گیرد.
\پایان{شمارش}

\پاسخ

در یک ماتریس {$a$} نواری با {$n$} سطر و {$n$} ستون دارای {$n$} عنصر غیر صفر بر روی قطر اصلی، {$n-1$} عنصر غیر صفر بر روی قطر بالای قطر اصلی و {$n-1$} عنصر غیر صفر بر روی پایین قطر اصلی هستیم و به همین ترتیب. می‌توان تعداد کل عناصر غیر صفر را در قالب مجموع زیر بیان کرد:
\begin{displaymath}
n+\sum_{i=1}^{a-1}{2(n-i)}
\end{displaymath}

ب. اگر {$M[i,j]$} عنصری با مقدار غیر صفر از ماتریس {$a$} نواری {$M$} باشد آنگاه {$M[i,j]$} در یکی از سه حالت زیر صدق می‌کند:
\شروع{شمارش}
\فقره {$M[i,j]$} بر روی قطر اصلی قرار دارد که در این صورت داریم {$i=j$}.
\فقره {$M[i,j]$} بر روی یکی از {$a-1$} قطر بالای قطر اصلی قرار دارد که در این صورت اندیس {$j$} باید حداکثر {$a-1$} واحد از اندیس {$i$} بزرگتر باشد یعنی {$i<j\leq i+a-1$}.
\فقره {$M[i,j]$} بر روی یکی از {$a-1$} قطر پایین قطر اصلی قرار دارد که در این حالت اندیس {$i$} باید حداکثر {$a-1$} واحد از اندیس {$j$} بزرگتر باشد یعنی {$j<i\leq j+a-1$}.
\پایان{شمارش}

ج. اگر فرض کنیم ماتریس {$a$} نواری {$M$} با {$n$} سطر و {$n$} ستون را در آرایه‌ی یک بعدی {$B$} با تعریف
 {$B[1\twodots n+2\sum_{i=1}^{a-1}{(n-i)]}$} ذخیره کرده‌ایم آنگاه برای بازیابی مقدار {$M[i,j]$} باید یکی از سه حالت زیر را در نظر گرفت:
\شروع{فقرات}
\فقره اگر {$i=j$}:
\begin{displaymath}
M[i,j]=B[\sum_{k=1}^{a-1}{(n-k)}+(i-1)]
\end{displaymath}
\فقره اگر {$i>j$}:
\begin{displaymath}
M[i,j]=B[n+\sum_{k=1}^{a-1}{(n-k)}+\sum_{k=1}^{i-j+1}{(a-k)}+(i-1)]
\end{displaymath}
\فقره اگر {$i<j$}:
\begin{displaymath}
M[i,j]=B[i-1+\sum_{k=j-i+1}^{a-1}{(n-k)}]
\end{displaymath}
\پایان{فقرات}