\فصل{مرتبه‌ی زمانی}
\قسمت{مقدمه}
در بررسی داده‌ساختارها و الگوریتم‌ها معمولا دو موضوع حافظه‌ و زمان مصرفی مورد توجه قرار می‌گیرند که از میان این دو زمان مصرفی از اهمیت بیشتری برخوردار است. در حالت ایده‌آل همیشه به دنبال داده‌ساختارها و الگوریتم‌هایی هستیم که با کمترین حافظه و بیشترین سرعت اجرا شوند.

مرتبه‌ی زمانی ابزاری است که به کمک آن می‌توان در مورد زمان اجرای عملیات داده‌ساختارها و الگوریتم‌ها بحث کرد و آنها را از نظر زمان اجرا با یکدیگر مقایسه کرد. با توجه به اهمیت مبحث مرتبه‌ی زمانی از آن به عنوان سنگ بنای دروس داده‌ساختارها و طراحی الگوریتم یاد می‌شود.

با توجه به گستردگی و اهمیت مبحث مرتبه‌ی زمانی این فصل به بخش‌هایی تقسیم شده است و سوالات هر بخش به بررسی جنبه‌ای از مرتبه‌ی زمانی می‌پردازد.

\قسمت{منابع مطالعاتی}
معمولا در تمامی کتاب‌هایی که به بحث و بررسی داده‌ساختارها و طراحی الگوریتم‌ها می‌پردازند، فصل یا فصولی به معرفی مرتبه‌ی زمانی اختصاص داده می‌شود. برای مطالعه در مورد مفهوم مرتبه‌ی زمانی، نمادهای مجانبی و بزرگی توابع می‌توانید به فصل سوم {\cite{clrs}} و فصل اول {\cite{ebrahimi}} مراجعه کنید. برای کسب اطلاعات در مورد الگوریتم‌های بازگشتی و به دست آوردن مرتبه‌ی زمانی چنین الگوریتم‌هایی می‌توانید به فصل چهارم {\cite{clrs}} و فصل دوم {\cite{ebrahimi}} مراجعه کنید.

\قسمت{مفهوم مرتبه‌ی زمانی}
\سوال آرایه‌ی‌‌ {$A$} را در نظر بگیرید. هر یک از خانه‌ها‌ی آرایه‌ی {$A$} شامل عددی صحیح در بازه‌ی {$[1,256]$} است. الگوریتم {\eqref{ch1:alg:cntRep}} تعداد تکرار هر عدد در آرایه‌‌ی {$A$} را به دست می‌آورد.

\begin{algorithm}
\caption{شمارش تعداد تکرار اعداد در یک آرایه یک بعدی}\label{ch1:alg:cntRep}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{CountRepetition}{$A$}
	\State let $C[1..256]$ be a new array of type integer
	\State $n \gets \attrib{A}{length}$
	\For{$i \gets 1 \To 256$}
		\State $C[i] \gets 0$
	\EndFor
	\For{$i \gets 1 \To n$}
			\State $\id{C[A[i]]} \gets \id{C[A[i]]}+1$
	\EndFor	
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

با در نظر گرفتن الگوریتم {\eqref{ch1:alg:cntRep}} به موارد زیر پاسخ دهید.
\شروع{شمارش}[A.]
\فقره با توجه به اندازه‌ی ورودی\پانوشت{منظور از اندازه‌ی ورودی همان تعداد خانه‌های آرایه‌ی {$A$} است.}، چه تعداد عمل جمع و چه تعداد عمل انتساب در این الگوریتم انجام می‌شود؟ 
\فقره اگر مجموع انتساب‌ها و جمع‌های انجام ‌شده را به عنوان کل اعمال انجام ‌شده در نظر بگیریم آنگاه چه درصدی از کل اعمال، هنگامی که آرایه‌ی {$A$} دارای ۵۰۰ خانه است، مربوط به حلقه اول و چه درصدی مربوط به حلقه دوم است؟ اگر آرایه‌ی {$A$} دارای ۵۰۰۰۰ خانه باشد، این درصدها چگونه خواهند بود؟
\فقره کدامیک از دو حلقه‌ی موجود در الگوریتم تاثیر بیشتری در مرتبه‌ی زمانی الگوریتم دارد؟
\پایان{شمارش}

\پاسخ

آ. بدنه‌ی حلقه‌‌ی اول ۲۵۶ بار اجرا و در هر بار اجرا یک عمل انتساب انجام می‌شود. بدنه‌ی حلقه‌ی دوم {$n$} بار اجرا می‌شود و در هر بار اجرا یک عمل انتساب و یک عمل جمع صورت می‌پذیرد. در نتیجه تعداد انتساب‌‌های انجام ‌شده در حلقه دوم {$n$} و تعداد جمع‌ها نیز برابر با {$n$} است. به این ترتیب می‌توان گفت برای دو حلقه در مجموع {$n+256$} عمل انتساب و {$n$} عمل جمع انجام می‌شود. به عبارت دیگر در الگوریتم {\eqref{ch1:alg:cntRep}} در مجموع {$2n+512$} عمل انجام می‌شود که {$n$} همان تعداد خانه‌های آرایه‌ی ورودی است.

ب. اگر آرایه‌ی ورودی دارای ۵۰۰ خانه باشد آنگاه تعداد کل اعمال برابر با ۱۵۱۲ خواهد بود که از این تعداد، ۲۵۶ عمل متعلق به حلقه‌ی اول و ۱۲۵۶ عمل متعلق به حلقه‌ی دوم است. به این ترتیب می‌توان گفت به طور تقریبی ۱۷ درصد از کل اعمال انجام ‌شده مربوط به حلقه‌ی اول و ۸۳ درصد مربوط به حلقه‌ی دوم است.

حال اگر فرض کنیم آرایه دارای ۵۰۰۰۰ خانه است آنگاه الگوریتم در کل ۱۰۰۵۱۲ عمل را انجام خواهد داد که از این تعداد دوباره ۲۵۶ عمل متعلق به حلقه‌ی اول است اما تعداد اعمال حلقه‌ی دوم به ۱۰۰۲۵۶ افزایش می‌یابد. در این حالت به طور تقریبی {$0.25$} درصد از کل اعمال متعلق به حلقه‌ی اول و {$99.75$} درصد متعلق به حلقه‌ی دوم است.
 
ج. \متن‌خوابیده{تعداد} اعمال انجام ‌شده در حلقه‌ی اول با افزایش اندازه‌ی ورودی تغییر نمی‌کند (تعداد اعمال این حلقه همواره ۲۵۶ است) اما \متن‌خوابیده{درصد} اعمال انجام شده در این حلقه، نسبت به کل اعمال، با افزایش اندازه‌ی ورودی کاهش می‌یابد. این یعنی اگر اندازه‌ی ورودی بسیار بزرگ باشد می‌توان اعمال انجام شده در حلقه‌ی اول را نادیده گرفت زیرا تعداد اعمال انجام شده در این حلقه تاثیری در تعیین مرتبه‌ی زمانی الگوریتم نخواهد داشت.

به این ترتیب می‌توان گفت برای تحلیل مرتبه‌ی زمانی یک الگوریتم می‌توان بدون در نظر گرفتن بخش‌هایی از الگوریتم که با تغییر اندازه‌ی ورودی زمان اجرای آنها تغییری نمی‌کند کار تحلیل را انجام داد. به بیان دیگر برای تحلیل مرتبه‌ی زمانی یک الگوریتم کافیست قسمت‌هایی از الگوریتم که زمان اجرای آنها به اندازه‌ی ورودی بستگی دارد مورد تحلیل قرار بگیرند.

\سوال چرا عبارت {\prq}زمان اجرای الگوریتم {$A$} حداقل از مرتبه {$O(n^2)$} است{\plq} هیچ اطلاع مفیدی درباره‌ی زمان اجرای الگوریتم {$A$} در اختیار ما قرار نمی‌دهد؟

\پاسخ

فرض کنید {$T(n)$} نشان دهنده‌ی زمان اجرای الگوریتم {$A$} باشد. در این صورت عبارت مطرح شده در صورت سوال بیان می‌دارد که {$T(n) \geq O(n^2)$}. از آنجایی که تابعی مانند {$f(n)=0$} نیز عضو {$O(n^2)$} است در نتیجه می‌توان گفت {$T(n)\geq f(n)$} که این معادل است با {$T(n) \geq 0$}. از آنجایی که از قبل می‌دانیم زمان اجرای هر الگوریتم دلخواه مقداری غیر منفی است در نتیجه عبارت {$T(n) \geq 0$} هیچ اطلاع مفیدی درباره‌ی زمان اجرای الگوریتم {$A$} در اختیار ما قرار نمی‌دهد.

\سوال دو کامپیوتر {$A$} و {$‌B$} را در اختیار داریم که اولی توانایی اجرای ده میلیارد دستور در ثانیه و دومی توانایی اجرای ده میلیون دستور در ثانیه را دارد. به بیانی دیگر کامپیوتر {$A$} از نظر محاسباتی هزار برابر از کامپیوتر {$B$} سریعتر است. لیست {$L$} به طول {$n$} حاوی اعداد صحیح را در اختیار داریم و قصد داریم  آن را مرتب‌ کنیم. دو الگوریتم مرتب‌سازی طراحی کرده‌ایم که الگوریتم اول با انجام {$2n^2$} دستور و الگوریتم دوم با انجام {$50n\lg n$} دستور می‌تواند لیست {$L$} را مرتب کند. الگوریتم اول را بر روی کامپیوتر {$A$} و الگوریتم دوم را بر روی کامپیوتر {$B$} اجرا می‌کنیم. اگر طول لیست {$L$} برابر با ده میلیون باشد آنگاه هر یک از این دو کامپیوتر به چه مقدار زمان برای مرتب‌سازی لیست {$L$} نیاز دارند؟ با مقایسه‌ی زمان‌های به دست آمده چه نتیجه‌ای می‌توان گرفت؟

\پاسخ

زمان مورد نیاز کامپیوتر {$A$} برابر است با:
\begin{displaymath}
\frac{2\times{({10}^7)}^2}{{10}^{10}}=20000\ \text{ثانیه}
\end{displaymath}

و زمان مورد نیاز کامپیوتر {$B$} برابر است با:
\begin{displaymath}
\frac{50\times{10}^7\times\lg {10}^7}{{10}^7}\approx 1163\ \text{ثانیه}
\end{displaymath}

با مقایسه‌ی زمان‌های به دست آمده به نتیجه‌ای جالب می‌رسیم. گرچه کامپیوتر {$A$} هزار برابر سریعتر از کامپیوتر {$B$} است اما چون مرتبه‌ی زمانی الگوریتمی که بر روی کامپیوتر {$A$} اجرا شد از مرتبه‌ی الگوریتم اجرا شده بر روی کامپیوتر {$B$} بزرگتر بود در نتیجه عملیات مرتب‌سازی بر روی کامپیوتر {$B$} بسیار سریع‌تر انجام شد. به این ترتیب می‌توان دریافت چرا همیشه دانشمندان علوم کامپیوتر به دنبال الگوریتم‌هایی با مرتبه‌ی زمانی پایین هستند!

\سوال برای حل مسئله‌ی {$P$} الگوریتم‌های {$A$} و {$B$} را در اختیار داریم. هر دو الگوریتم را بر روی یک کامپیوتر پیاده‌سازی کرده‌ایم. اگر اندازه‌ی ورودی مسئله‌ی {$P$} را با {$n$} نشان دهیم آنگاه الگوریتم {$A$} به {$8n^2$} گام و الگوریتم {$B$} به {$64n\lg n$} گام برای حل مسئله‌ی {$P$} نیاز دارد. برای چه مقادیری از {$n$} الگوریتم {$A$} سریعتر از الگوریتم {$B$} مسئله‌ی {$P$} را حل می‌کند؟

\پاسخ

برای رسیدن به پاسخ باید نامعادله‌ی {$8n^2<64n\lg n$} را حل کنیم. این نامعادله را به صورت زیر ساده می‌کنیم:
\begin{displaymath}
8n^2 < 64n\lg n \Rightarrow n < 8\lg n \Rightarrow 2^{n/8} < n
\end{displaymath}
نامعادله‌ی فوق به ازای {$2\leq n\leq 43$} برقرار است. به این ترتیب می‌توان گفت گرچه مرتبه‌ی زمانی الگوریتم {$A$} از الگوریتم {$B$} بیشتر است اما این بدین معنی نیست که الگوریتم {$A$} همیشه کندتر از الگوریتم {$B$} عمل می‌کند.

\قسمت{نمادهای مجانبی و بزرگی توابع}

\سوال آیا می‌توان به ازای توابع دلخواه {$f$} و {$g$} برقراری یکی از روابط {$f(n)=O\big(g(n)\big)$} یا {$f(n)=\Omega \big(g(n)\big)$} را اثبات کرد؟

\پاسخ

خیر. ممکن است برای دو تابع دلخواه {$f$} و {$g$} نتوان درستی هیچ یک از دو رابطه‌ی {$f(n)=O\big(g(n)\big)$} و {$f(n)=\Omega \big(g(n)\big)$} را اثبات کرد. به طور مثال برای توابع {$f(n)=n$} و {$g(n)=n^{1+\sin n}$} نمی‌توان این روابط را اثبات کرد زیرا مقدار تابع {$g(n)$} در بازه‌ی {$[1,n^2]$} نوسان می‌کند و این بدین معنی است که تابع {$g(n)$} نه سقفی برای {$f(n)$} و نه کفی برای آن است. در چنین حالتی گفته می‌شود که توابع {$f(n)$} و {$g(n)$} مقایسه‌پذیر نیستند.

\سوال اگر {$f$}  و {$g$} توابع دلخواه غیرمنفی باشند، با توجه به تعریف نماد {$\Theta$}، درستی عبارت زیر را ثابت کنید.
\begin{displaymath}
\max \Bigl( f(n),g(n)\Bigr) =\Theta \Bigl( f(n)+g(n) \Bigr)
\end{displaymath}
\پاسخ

ابتدا تابع {$h(n)$}، که همان تعریف تابع {$\max$} است، را در نظر می‌گیریم:
\begin{equation}
h(n) =
\begin{cases}
f(n) &  f(n) \geq g(n)\\
g(n) & f(n) < g(n)
\end{cases}\label{ch1:eqn:maxFunDef}
\end{equation}
با در نظر گرفتن تعریف {\eqref{ch1:eqn:maxFunDef}} باید نشان‌ دهیم {$h(n) =\Theta \bigl( f(n)+g(n) \bigr)$}. بدین منظور ابتدا نشان می‌دهیم {$h(n) =O \bigl( f(n)+g(n) \bigr)$} و سپس نشان می‌دهیم {$h(n) =\Omega \bigl( f(n)+g(n) \bigr)$}.

با توجه به اینکه توابع {$f$} و {$g$} هر دو غیرمنفی هستند می‌توان نتیجه گرفت:
\begin{equation}
\begin{cases}
f(n)+g(n) \geq f(n)\\
f(n)+g(n) \geq g(n)
\end{cases}
\Longrightarrow f(n)+g(n) \geq h(n)\label{ch1:eqn:FpGleqH}
\end{equation}
با در نظر گرفتن رابطه‌ی {\eqref{ch1:eqn:FpGleqH}} و تعریف نماد مجانبی {$O$} خواهیم داشت:
\begin{equation}
h(n) \leq f(n)+g(n) \Rightarrow h(n) = O\Bigl( f(n)+g(n)\Bigr) \label{ch1:eqn:maxBigO}
\end{equation}
از طرف دیگر رابطه‌ی زیر نیز برقرار است:
\begin{displaymath}
\begin{cases}
h(n) \geq f(n)\\
h(n) \geq g(n)
\end{cases}
\Rightarrow 2h(n) \geq f(n)+g(n) \Rightarrow h(n) \geq \frac{1}{2} \Bigl( f(n)+g(n) \Bigr) 
\end{displaymath}
با در نظر گرفتن رابطه‌‌ی بالا و تعریف نماد مجانبی {$\Omega$} داریم:
\begin{equation}
\frac{1}{2} \Bigl( f(n)+g(n) \Bigr) \leq h(n) \Rightarrow h(n) = \Omega \Bigl( f(n)+g(n) \Bigr) \label{ch1:eqn:maxBigOmega}
\end{equation}
از {\eqref{ch1:eqn:maxBigO}}، {\eqref{ch1:eqn:maxBigOmega}} و تعریف نماد {$\Theta$} می‌توان به نتیجه‌ی دلخواه رسید:
\begin{displaymath}
 h(n)=max\Bigl( f(n),g(n)\Bigr) =\Theta \Bigl( f(n)+g(n) \Bigr)
\end{displaymath}

\سوال ثابت کنید برای هر دو عدد حقیقی و غیر منفی  {$a$} و {$b$} داریم {$(n+a)^b=\Theta (n^b)$}.

\پاسخ

بسط دوجمله‌ای نیوتن که در رابطه‌ی {\eqref{ch1:eqn:ns}} نشان داده شده است را در نظر می‌گیریم.
\begin{equation}
(x+y)^k=\sum_{i=0}^{k}{\binom{k}{i}x^{k-i}y^i}\label{ch1:eqn:ns}
\end{equation}
اگر در {\eqref{ch1:eqn:ns}} به ترتیب ابتدا {$n$} را جایگزین {$x$} ، سپس {$a$}  را جایگزین {$y$} و در نهایت {$b$} را جایگزین {$k$} کنیم به رابطه‌ی {\eqref{ch1:eqn:nsSubs}} می‌رسیم.
\begin{equation}
(n+a)^b=\sum_{i=0}^{b}{\binom{b}{i}n^{b-i}a^i}\label{ch1:eqn:nsSubs}
\end{equation}
با گسترش رابطه‌ی {\eqref{ch1:eqn:nsSubs}} خواهیم داشت:
\begin{equation}
(n+a)^b=\binom{b}{0}n^b + \binom{b}{1}n^{b-1}a^1 + \cdots +\binom{b}{b-1}n^1a^{b-1}+ \binom{b}{b}a^b\label{ch1:eqn:nsConstsSubs}
\end{equation}
اگر در {\eqref{ch1:eqn:nsConstsSubs}} مقادیر ثابت را با {$(0\leqslant r \leqslant b)\ c_r$} نشان دهیم آنگاه می‌توان رابطه‌ی {\eqref{ch1:eqn:nsConstsSubs}} را به صورت نشان داده شده در رابطه‌ی {\eqref{ch1:eqn:nsFinal}} بازنویسی کرد.
\begin{equation}
(n+a)^b=c_0n^b + c_1n^{b-1} + c_2n^{b-2}+ \cdots +c_{r-1}n^1+ c_rn^0\label{ch1:eqn:nsFinal}
\end{equation}
با توجه به رابطه‌ی {\eqref{ch1:eqn:nsFinal}} می‌توان نتیجه گرفت:
\begin{equation}
(n+a)^b \leq (b+1)n^b\label{ch1:eqn:maxFunRightPart}
\end{equation}
از طرف دیگر برقراری رابطه‌ی {\eqref{ch1:eqn:maxFunLeftPart}} نیز بدیهی است.
\begin{equation}
n^b \leq {(n+a)}^b\label{ch1:eqn:maxFunLeftPart}
\end{equation}
با در نظر گرفتن روابط {\eqref{ch1:eqn:maxFunRightPart}}، {\eqref{ch1:eqn:maxFunLeftPart}} و همچنین تعریف نماد {$\Theta$} می‌توان به نتیجه‌‌ی زیر دست یافت:
\begin{displaymath}
(n+a)^b=\Theta (n^b)
\end{displaymath}
به این ترتیب اثبات کامل است.

\سوال ثابت کنید رابطه‌ی {$2^n < n! < n^n$} برای مقادیر بزرگ {$n$} برقرار است.

\پاسخ

ابتدا نشان می‌دهیم نامساوی {$2^n < n!$} برقرار است. برای این منظور نامساوی زیر، که درستی آن بدیهی است، را در نظر می‌گیریم:
\begin{displaymath}
\underbrace{\lg 2 + \lg 2 + \cdots + \lg 2}_{n} < \underbrace{\lg n + \lg (n-1) + \lg (n-2) + \cdots + \lg 1}_{n}
\end{displaymath}
با خلاصه کردن نامساوی اخیر و گرفتن لگاریتم از طرفین آن داریم:
\begin{displaymath}
n\lg 2 < \lg n! \Rightarrow \lg 2^n < \lg n! \Rightarrow 2^n < n!
\end{displaymath}
بدین صورت نشان دادیم {$2^n$} از {$n!$} کوچکتر است.

برای اثبات نامساوی {$2^n < n!$} می‌توانستیم از تقریب استرلینگ\پانویس{{\lr{Stirling's approximation}}} نیز استفاده کنیم. این تقریب در رابطه‌ی {\eqref{ch1:eqn:stirlingApprox}} نشان داده شده است که در آن {$e$} نشان‌دهنده‌ی پایه‌ی لگاریتم طبیعی است.
\begin{equation}
n! = \dfrac{\sqrt{2n\pi}{\left( \dfrac{n}{e}\right)}^n\left( 1+\Theta\left(\dfrac{1}{n}\right)\right)}{2^n}\label{ch1:eqn:stirlingApprox}
\end{equation}
با در نظر گرفتن تقریب استرلینگ و استفاده از مفهوم حد می‌توان نوشت:
\begin{align*}
\lim_{n\to \infty} {\dfrac{n!}{2^n}} &=\lim_{n\to \infty}{\dfrac{\sqrt{2n\pi}{\left( \dfrac{n}{e}\right)}^n\left( 1+\Theta \left(\dfrac{1}{n}\right)\right)}{2^n}}\\
&=\lim_{n\to \infty}{ \sqrt{2n\pi}{\left( \dfrac{n}{2e}\right)}^n\left( 1+\Theta \left(\dfrac{1}{n}\right)\right)}\\
&= \infty
\end{align*}
چون حاصل حد بالا برابر با بی‌نهایت شد می‌توان گفت صورت کسر از مخرج آن بزرگتر است و این یعنی {$2^n < n!$}.

در ادامه نشان خواهیم داد نامساوی {$n! < n^n$} نیز برقرار است. درستی نامساوی {\eqref{ch1:eqn:factIneq}} بدیهی است.
\begin{equation}
\underbrace{1 \times 2\times 3 \times \cdots \times n}_{n} < \underbrace{ n \times n \times n \times \cdots \times n }_{n}\label{ch1:eqn:factIneq}
\end{equation}
اگر نامساوی {\eqref{ch1:eqn:factIneq}} را به شکل خلاصه ‌شده بنویسیم داریم {$n! < n^n$}.

اثبات اخیر را، مانند قسمت قبل، می‌توان با استفاده از تقریب استرلینگ هم انجام داد. بدین منظور خواهیم داشت:
\begin{align*}
\lim_{n\to \infty} {\dfrac{n!}{n^n}} &=\lim_{n\to \infty}{\dfrac{\sqrt{2n\pi}{\left( \dfrac{n}{e}\right)}^n\left( 1+\Theta \left(\dfrac{1}{n}\right)\right)}{n^n}}\\
&=\lim_{n\to \infty}{ \sqrt{2n\pi}{\left( \dfrac{n}{ne}\right)}^n\left( 1+\Theta\left(\dfrac{1}{n}\right)\right)}\\
&=\lim_{n\to \infty}{ \frac{\sqrt{2n\pi}\left( 1+\Theta\left(\dfrac{1}{n}\right)\right)}{e^n}}\\
&= 0
\end{align*}
چون حاصل حد بالا برابر با صفر شد می‌توان گفت {$n!$} از {$n^n$} کوچکتر است.

با توجه به اینکه درستی هر دو نامساوی  {$2n < n!$} و {$n! < n^n$} را اثبات کردیم در نتیجه می‌توان گفت رابطه‌ی {$2n < n! < n^n$} نیز برقرار است و به این ترتیب اثبات کامل است.

\سوال درستی رابطه‌ی {$\lg n! = \Theta (n\lg n)$} را اثبات کنید.

\پاسخ

به منظور اثبات درستی رابطه‌ی {$\lg n! = \Theta (n\lg n)$} ابتدا درستی رابطه‌ی {$\lg n! = O(n\lg n)$} و سپس درستی رابطه‌ی
{$\lg n! = \Omega (n\lg n)$} را اثبات می‌کنیم.

برای نشان دادن اینکه رابطه‌‌ی {$\lg n! = O(n\lg n)$} برقرار است نامساوی {\eqref{ch1:eqn:nFactnn}} را در نظر می‌گیریم.
\begin{equation}
\underbrace{1 \times 2 \times 3 \times \cdots \times n}_{n} \leq \underbrace{n \times n \times n \times \cdots \times n}_{n}\label{ch1:eqn:nFactnn}
\end{equation}
با خلاصه کردن و لگاریتم گرفتن از طرفین رابطه‌ی {\eqref{ch1:eqn:nFactnn}} به نامساوی {$\lg n! \leqslant n\lg n$} می‌رسیم و این بدین معنی است که {$\lg n! = O(n\lg n)$}. 

نشان دادن برقراری رابطه‌ی {$\lg n! = \Omega (n\lg n)$} کمی مشکلتر است. بدین منظور نامساوی {\eqref{ch1:eqn:n2Factn}} را در نظر می‌گیریم.
\begin{equation}
\underbrace{\frac{n}{2} \times \frac{n}{2} \times \cdots \times \frac{n}{2}}_{n/2} \leq \underbrace{1 \times 2 \times \cdots \times n}_{n}\label{ch1:eqn:n2Factn}
\end{equation}
با خلاصه کردن و لگاریتم گرفتن از طرفین رابطه‌ی {\eqref{ch1:eqn:n2Factn}} به رابطه‌ی {\eqref{ch1:eqn:n2lgnFactlgn}} می‌رسیم.
\begin{equation}
\lg {\left(\dfrac{n}{2}\right)}^\frac{n}{2} \leq \lg n! \Rightarrow \frac{n}{2}( \lg n - 1) \leq \lg n! \Rightarrow \frac{n}{2}\lg n - \frac{n}{2}\leq \lg n!\label{ch1:eqn:n2lgnFactlgn}
\end{equation}
می‌دانیم که رابطه‌ی {$(n/2)\lg n - (n/2)=\Theta (n \lg n)$} برقرار است. در نتیجه می‌توان گفت {$n\lg n$} کفی برای {$(n/2)\lg n - (n/2)$} است. از طرفی با در نظر گرفتن {\eqref{ch1:eqn:n2lgnFactlgn}} می‌توان گفت {$n\lg n$} کفی برای {$\lg n!$} نیز هست و این یعنی {$\lg n! = \Omega (n \lg n)$}.

با توجه به اینکه نشان دادیم هر دو رابطه‌ی {$\lg n! = O(n\lg n)$} و {$\lg n! = \Omega (n \lg n)$} برقرار هستند پس می‌توان نتیجه گرفت رابطه‌ی {$\lg n! = \Theta ( n\lg n)$} نیز برقرار است و به این ترتیب اثبات کامل است.

\سوال می‌گوییم تابع {$f$} به صورت چندجمله‌ای کراندار است اگر به ازای ثابتی مانند {$k$} داشته باشیم {$f(n)=O(n^k)$}. آیا
 {$\lceil \lg n \rceil !$} به صورت چندجمله‌ای کراندار است؟ در مورد {$\lceil \lg \lg n \rceil !$} چه می‌توان گفت؟ 

\پاسخ

ادعا می‌کنیم {$\lceil \lg n \rceil !$} به صورت چندجمله‌ای کراندار نیست اما {$\lceil \lg \lg n \rceil !$} به صورت چندجمله‌ای کراندار است.

قبل از اثبات ادعای مطرح شده به ذکر دو نکته که در اثبات‌ها از آنها استفاده خواهد شد می‌پردازیم.

\متن‌سیاه{نکته اول}: تابع {$f$} به صورت چندجمله‌ای کراندار است اگر و فقط اگر {$\lg f(n)=O(\lg n)$}. دلایل این نتیجه‌گیری عبارت‌اند از:
\شروع{فقرات}
\فقره اگر تابع {$f$} به صورت چندجمله‌ای کراندار باشد آنگاه ثوابت {$n_0$}، {$c$} و {$k$} وجود دارند به طوری که برای تمامی {$n$}های بزرگتر یا مساوی {$n_0$} داریم {$f(n)\leqslant cn^k$}. با لگاریتم گرفتن از طرفین این نامساوی به عبارت {$\lg f(n) \leqslant kc\lg n$} می‌رسیم و این یعنی {$\lg f(n)=O(\lg n)$}.
\فقره اگر {$\lg f(n)=O(\lg n)$} آنگاه {$f$} به صورت چندجمله‌ای کراندار است.
\پایان{فقرات}

\متن‌سیاه{نکته دوم}: دو رابطه‌ی زیر همواره برقرار هستند:
\شروع{شمارش}
\فقره {$\lg n! = \Theta ( n\lg n)$}
\فقره {$\lceil \lg n \rceil = \Theta ( \lg n)$}
\پایان{شمارش}

اثبات کراندار نبودن {$\lceil \lg n \rceil !$}:

اگر در رابطه‌ی اول از نکته‌ی دوم به جای {$n$} قرار دهیم {$\lceil \lg n \rceil$} آنگاه داریم:
\begin{displaymath}
 \lg \bigl(\lceil \lg n \rceil !\bigr) = \Theta \bigl(\lceil \lg n \rceil \lg \lceil \lg n \rceil \bigr)
\end{displaymath}
با در نظر گرفتن رابطه‌ی دوم از نکته‌ی دوم و رابطه فوق می‌توان نوشت:
\begin{displaymath}
 \lg \bigl(\lceil \lg n \rceil !\bigr) =\Theta \bigl(\lceil \lg n \rceil \lg \lceil \lg n \rceil \bigr) = \Theta \bigl(\lg n \lg \lg n \bigr)=\omega \bigl( \lg n \bigr)
\end{displaymath}
بدین صورت نشان دادیم تابع {$\lg n$} به عنوان یک مقدار کف برای تابع {$ \lg \bigl(\lceil \lg n \rceil !\bigr)$} است و نه سقفی برای آن. پس با در نظر گرفتن نکته‌ی اول می‌توان گفت {$\lceil \lg n \rceil !$} به صورت چندجمله‌ای کراندار نیست.

اثبات کراندار بودن {$\lceil \lg \lg n \rceil !$}:

اگر در رابطه‌ی اول از نکته‌ی دوم به جای {$n$} قرار دهیم {$\lceil \lg \lg n \rceil$} خواهیم داشت:
\begin{displaymath}
 \lg \bigl(\lceil \lg \lg n \rceil !\bigr) = \Theta \bigl(\lceil \lg \lg n \rceil \lg \lceil \lg \lg n \rceil \bigr)
\end{displaymath}
با در نظر گرفتن رابطه‌ی دوم از نکته‌ی دوم و رابطه بالا می‌توان نوشت:
\begin{displaymath}
 \lg \bigl(\lceil \lg \lg n \rceil !\bigr) = \Theta \bigl(\lceil \lg \lg n \rceil \lg \lceil \lg \lg n \rceil \bigr) = \Theta \bigl(\lg \lg n \lg \lg \lg n \bigr)
\end{displaymath}
چون {$\lg \lg \lg n$} از {$\lg \lg n$} کوچکتر است در نتیجه رابطه‌ی فوق را به صورتی که در ادامه آمده است در نظر می‌گیریم:
\begin{displaymath}
 \lg \bigl(\lceil \lg \lg n \rceil !\bigr) = \Theta \bigl(\lg \lg n \lg \lg \lg n \bigr) = o\bigl( {\lg}^2 \lg n \bigr)
\end{displaymath}
چون برای هر دو عدد حقیقی {$a \geqslant 0$} و {$b \geqslant 0$} رابطه‌ی {${\lg}^bn=o(n^a)$} برقرار است اگر در این رابطه به جای {$n$} قرار دهیم {$\lg n$}، به جای {$a$} مقدار ۱ و به جای {$b$} مقدار ۲ را قرار دهیم آنگاه می‌توان رابطه‌ی فوق را به صورت زیر نوشت:
\begin{displaymath}
 \lg \bigl(\lceil \lg \lg n \rceil !\bigr) = o\bigl( {\lg}^2 \lg n \bigr) = o(\lg n)
\end{displaymath}
به این ترتیب اثبات کردیم {$\lg n$} سقفی برای {$\lg \bigl(\lceil \lg \lg n \rceil !\bigr)$} است و طبق نکته‌ی اول، این بدین معنی است که تابع {$\lceil \lg \lg n \rceil !$} به صورت چندجمله‌ای کراندار است.

\سوال توابعی که در ادامه آمده است را بر حسب نرخ رشد و به صورت صعودی مرتب کنید. در صورتیکه دو تابع دارای نرخ رشد یکسان بودند، از علامت تساوی بین دو تابع استفاده کنید (در تمام توابع فرض کنید {$n$} عددی مثبت و بزرگ است).
\begin{center}
\begin{tabular}{ccccccccc}
$8^{\lg n}$ & $\lg n$ & ${\bigl(\sqrt{2}\bigr)}^{\lg n}$ & $n!$ & ${\Bigl( \dfrac{3}{2}\Bigr) }^n$ & $n^{1/\lg n}$ & $2^{\sqrt{2\lg n}}$ & $(\lg n)!$ & $2^{\lg n}$\\[0.4cm]
$2^{2^{n+1}}$ & $2^{2^{n}}$ & $\lg n!$ & ${(\lg n)}^{\lg n}$ & $2^n$ & $n^2$ & $n^n$ & $\ln \ln n$ & $\ln n$\\[0.4cm]
${\lg}^2 n$ & $n$ & $\sqrt{n}$ & $4^{\lg n}$ & $n^3$ & $n2^n$ & $\sqrt{\lg n}$ & $e^n$ & $n\lg n$
\end{tabular}
\end{center}

\پاسخ

لیست مرتب ‌شده‌ی توابع در ادامه آمده است. در این لیست توابع از چپ به راست به ترتیب صعودی نوشته شده‌اند.
\begin{center}
\begin{LTR}
\begin{tabular}{ccccc}
$n^{1/\lg n}$ & $\ln \ln n$ & $\sqrt{\lg n}$ & $\lg n = \ln n$ & ${\lg}^2 n$\\[0.4cm]
$2^{\sqrt{2\lg n}}$ & ${\bigl(\sqrt{2}\bigr)}^{\lg n} = \sqrt{n}$ & $n = 2^{\sqrt{\lg n}}$ & $n\lg n = \lg n!$ & $n^2 = 4^{\lg n}$\\[0.4cm]
$n^{3} = 8^{\lg n}$ & $(\lg n)!$ & ${(\lg n)}^{\lg n}$ & ${\Bigl( \dfrac{3}{2}\Bigr) }^n$ & $2^n$\\[0.4cm]
$n2^n$ & $e^n$ & $n!$ & $n^n$ & $2^{2^n}$\\[0.4cm]
$2^{2^{n+1}}$
\end{tabular}
\end{LTR}
\end{center}
در ادامه نشان داده می‌شود که ترتیب برخی از توابع چگونه به دست آمده‌‌ است.

\شروع{شمارش}
\فقره تابع {$n^{1/\lg n}$} را به صورتی که در ادامه آمده است ساده می‌کنیم:
\begin{displaymath}
n^{1/\lg n}=n^{\log_n{2}}=2^{\log_n{n}}=2
\end{displaymath}
پس تابع {$n^{1/\lg n}$} معادل با عدد ۲ است. چون سایر توابع داده شده دارای رشد مثبت هستند در نتیجه عدد ۲ دارای کوچکترین مرتبه‌ی رشد است و تابع {$n^{1/\lg n}$} در ابتدای لیست، به عنوان تابعی با کمترین نرخ رشد، قرار می‌گیرد.

\فقره می‌دانیم برای هر دو عدد حقیقی {$a>1$} و {$b$} رابطه‌ی {\eqref{ch1:eqn:limnboveran}} برقرار است.
\begin{equation}
\lim_{n\to \infty}{\frac{n^b}{a^n}}=0\label{ch1:eqn:limnboveran}
\end{equation}
 اگر در {\eqref{ch1:eqn:limnboveran}} به جای {$n$} قرار دهیم {$\lg n$} و به جای {$a$} قرار دهیم {$2^a$} آنگاه می‌توان نوشت:
\begin{displaymath}
\lim_{n\to \infty}{\dfrac{{\lg}^b n}{{(2^a)}^{\lg n}}}=0\Rightarrow\lim_{n\to \infty}{\dfrac{{\lg}^b n}{{(2^{\lg n})}^a}}=0\Rightarrow\lim_{n\to \infty}{\dfrac{{\lg}^b n}{{(n^{\lg 2})}^a}}=0\Rightarrow\lim_{n\to \infty}{\dfrac{{\lg}^b n}{n^a}}=0
\end{displaymath}
چون حاصل حد فوق برابر با صفر است می‌توان رابطه‌ی {${\lg}^b n=O(n^a)$} را نتیجه گرفت. حال اگر قرار دهیم {$b=1$} و {$a=1/2$}  خواهیم داشت {$\lg n = O(\sqrt{n})$} و این یعنی {$\sqrt{n}$} دارای نرخ رشد بیشتری نسبت به {$\lg n$} است. در نتیجه در لیست مرتب شده‌ی توابع، {$\lg n$} باید قبل از {$\sqrt{n}$} قرار بگیرد.

\فقره می‌دانیم نامساوی {$\lg n < n$} برای هر {$n \geqslant 1$} برقرار است. با ضرب {$n$} در طرفین این نامساوی به نامساوی {$n\lg n < n^2$} می‌رسیم و این یعنی نرخ رشد {$n\lg n$} از {$n^2$} کمتر است.

\فقره درستی نامساوی {\eqref{ch1:eqn:lgnfactltlgnlgn}} بدیهی است.
\begin{equation}
\underbrace{1 \times 2 \times 3 \times \cdots \times \lg n}_{\lg n} < \underbrace{\lg n \times  \lg n \times \cdots \times \lg n}_{\lg n}\label{ch1:eqn:lgnfactltlgnlgn}
\end{equation}
عبارت سمت چپ در نامساوی {\eqref{ch1:eqn:lgnfactltlgnlgn}} برابر با {$(\lg n)!$} و عبارت سمت راست برابر با {${(\lg n)}^{\lg n}$} است. در نتیجه می‌توان گفت نرخ رشد {$(\lg n)!$} از {${(\lg n)}^{\lg n}$} کمتر است.

\فقره برای اثبات اینکه نرخ رشد تابع {${\lg}^2 n$}  از {$2^{\sqrt{2\lg n}}$} کمتر است، یعنی {${\lg}^2 n < 2^{\sqrt{2\lg n}}$}، کافی است ابتدا از طرفین این نامساوی لگاریتم بر پایه‌ی دو بگیریم:
\begin{displaymath}
\lg {\lg}^2 n < \lg 2^{\sqrt{2\lg n}} \Rightarrow 2\lg \lg n < \sqrt{2\lg n}\Rightarrow \lg \lg n < \dfrac{\sqrt{2}}{2}\sqrt{\lg n}
\end{displaymath}
با در نظر گرفتن نامساوی اخیر و اثبات مورد شماره‌ی ۲ می‌توان برقراری رابطه‌ی {${\lg}^2 n < 2^{\sqrt{2\lg n}}$} را نتیجه گرفت.

\فقره برای اثبات نامساوی {$2^{\sqrt{2\lg n}}< \sqrt{n}$} می‌توان مانند مورد ۵ از دو طرف نامساوی لگاریتم بر پایه‌ی دو گرفت و اثبات را به روشی مشابه انجام داد.

\فقره این قسمت به اثبات برقراری نامساوی {${(\lg n)}^{\lg n} < {(3/2)}^n$} اختصاص دارد. می‌دانیم که برای هر {$n \geqslant 4$} نامساوی‌های {$n^{1/2} \geqslant \lg n$} و {$n^{1/2} \geqslant \lg \lg n$} برقرار هستند. با ضرب طرفین این دو نامساوی در یکدیگر می‌توان به نتیجه‌ای که در ادامه آمده است رسید.
\begin{displaymath}
n \geq \lg n \lg \lg n \Rightarrow n \geq \lg_{\frac{3}{2}} n\lg \lg n
\end{displaymath}
اگر عدد {$3/2$} را به عنوان پایه‌ی توان برای طرفین نامساوی اخیر در نظر بگیریم آنگاه به نامساوی {\eqref{ch1:eqn:eqn1}} می‌رسیم.
\begin{equation}
{\left( \frac{3}{2}\right)}^n > {\left( \frac{3}{2}\right)}^{\lg_{\frac{3}{2}} n\lg \lg n}\label{ch1:eqn:eqn1}
\end{equation}
عبارت سمت راست نامساوی {\eqref{ch1:eqn:eqn1}} را می‌توان به صورت زیر ساده کرد:
\begin{displaymath}
{\left( \frac{3}{2}\right)}^{\lg_{\frac{3}{2}} n\lg \lg n}={\left({\left( \frac{3}{2}\right)}^{\lg_{\frac{3}{2}} n}\right)}^{\lg \lg n} = n^{\lg \lg n} = {(\lg n)}^{\lg n}
\end{displaymath}

به این ترتیب اگر به جای عبارت سمت راست نامساوی {\eqref{ch1:eqn:eqn1}} عبارت معادل آن یعنی {${(\lg n)}^{\lg n}$} را قرار دهیم داریم:
\begin{displaymath}
{\left( \frac{3}{2}\right)}^n > {(\lg n)}^{\lg n}
\end{displaymath}
و این یعنی نرخ رشد تابع {${(3/2)}^n$} بیشتر از {${(\lg n)}^{\lg n}$} است.
\فقره اثبات برقراری نامساوی {$n! < n^n < 2^{2^n}$} به راحتی صورت می‌پذیرد. می‌دانیم که نامساوی {$n\lg n < 2^n$} برقرار است. حال اگر عدد دو را به عنوان پایه‌ی توان برای طرفین این نامساوی در نظر بگیریم آنگاه می‌توان نتیجه‌گیری زیر را انجام داد:
\begin{equation*}
2^{n\lg n} < 2^{2^n} \Rightarrow {(2^{\lg n})}^n < 2^{2^n} \Rightarrow {(n^{\lg 2})}^n < 2^{2^n} \Rightarrow n^n < 2^{2^n}
\end{equation*}
پس نامساوی {$n^n < 2^{2^n}$} برقرار است.

با توجه به برقراری نامساوی بدیهی زیر می‌توان به درستی نامساوی {$n! < n^n$} نیز پی برد:
\begin{displaymath}
n! = \underbrace{1 \times 2 \times 3 \times \cdots \times n}_{n} \leq \underbrace{ n \times n \times n \times \cdots \times n}_{n}=n^n
\end{displaymath}
چون هر دو نامساوی {$n^n < 2^{2^n}$} و {$n! < n^n$} برقرار هستند پس نامساوی {$n! < n^n < 2^{2^n}$} نیز برقرار است و  این بدین معنی است که در لیست مرتب ‌شده‌ی توابع، {$n!$} قبل از {$n^n$} و {$n^n$} قبل از {$2^{2^n}$} قرار می‌گیرد.
\پایان{شمارش}

\سوال با فرض اینکه توابع {$f$} و {$g$} هر دو غیرمنفی هستند درستی هر یک از موارد زیر را اثبات یا رد کنید.
\begin{enumerate}
\item $f(n)=O\Bigl( f^2(n) \Bigr)$
\item $f(n)=O\bigl( g(n) \bigr) \Rightarrow 2^{f(n)}=O\Bigl( 2^{g(n)} \Bigr)$
\item $f(n)+o\bigl( f(n) \bigr) = \Theta \bigl( f(n)\bigr)$
\end{enumerate}
\پاسخ

مورد اول نادرست است. اگر تابع {$f(n)$} دارای مقداری همواره کمتر از یک باشد، مثلاً قرار دهیم {$f(n)=1/n$}، آنگاه داریم {$f^2(n) \leqslant f(n)$} و این یعنی {$f^2(n)$} نمی‌تواند سقفی برای {$f(n)$} باشد.

مورد دوم نیز نادرست است. با استفاده از یک مثال نقض می‌توان به این موضوع پی ‌برد. اگر قرار دهیم {$f(n)=2\lg n$} و {$g(n)=\lg n$} آنگاه می‌دانیم که {$f(n)=O\bigl( g(n) \bigr)$} اما {$2^{f(n)}$} برابر است با {$n^2$} و {$2^{g(n)}$} برابر است با {$n$} و می‌دانیم که {$n$} نمی‌تواند سقفی برای {$n^2$} باشد.

مورد سوم درست است. فرض می‌کنیم تابعی مانند {$g(n)$} وجود دارد بطوریکه {$g(n)=o\bigl( f(n) \bigr)$}. با توجه به اینکه توابع {$f$} و {$g$} هر دو غیرمنفی هستند می‌توان نوشت:
\begin{equation}
f(n) \leq f(n)+g(n)  \label{ch1:eqn:fLeqPlusg}
\end{equation}
 از طرفی با در نظر گرفتن تعریف {$o\bigl( f(n) \bigr)$} که در ادامه آمده است:
 \begin{equation}
o\bigl( f(n) \bigr) = \lbrace g(n)\ |\ \forall c > 0,\exists n_0>0,\forall n\geq n_0: g(n) < cf(n) \rbrace\label{ch1:eqn:littleoDef}
\end{equation}
و افزودن {$f(n)$} به طرفین نامساوی موجود در {\eqref{ch1:eqn:littleoDef}} می‌توان نوشت:
\begin{equation}
f(n)+g(n) < cf(n) + f(n)=(c+1)f(n) \label{ch1:eqn:fPlusgLessf}
\end{equation}
با ترکیب {\eqref{ch1:eqn:fLeqPlusg}} و {\eqref{ch1:eqn:fPlusgLessf}} داریم:
\begin{displaymath}
f(n) \leq f(n)+g(n) \leq (c+1)f(n)
\end{displaymath}
و این یعنی {$f(n)+g(n)=\Theta \bigl( f(n) \bigr)$}.

چون {$g(n)$} را به عنوان یک تابع دلخواه متعلق به {$o\bigl( f(n) \bigr)$} انتخاب کردیم و نشان دادیم رابطه‌ی
 {$f(n)+g(n)=o \bigl( f(n) \bigr)$} برقرار است پس می‌توان نتیجه گرفت برای تمام توابع متعلق به {$o\bigl( f(n) \bigr)$} رابطه‌ی {$f(n)+o\bigl( f(n) \bigr) = \Theta \bigl( f(n)\bigr)$} برقرار است.

\قسمت{روابط بازگشتی}

\سوال بزرگترین مقسوم ‌علیه مشترک دو عدد {$m$} و {$n$} برابر است با بزرگترین عددی که هم بر {$m$} و هم بر {$n$} بخش‌پذیر است. برای مثال بزرگترین مقسوم ‌علیه مشترک دو عدد 9 و 15 برابر با 3 است. از الگوریتم {\eqref{ch1:alg:gcd}} می‌توان برای محاسبه‌ی بزرگترین مقسوم ‌علیه مشترک دو عدد استفاده کرد (در این الگوریتم {$\bmod$} بیانگر عملگر باقیمانده است). یک رابطه‌ی بازگشتی‌ ارائه دهید که نشان‌دهنده‌ی تعداد اعمال {{$\bmod$ انجام شده توسط این الگوریتم باشد.

\begin{algorithm}
\caption{به دست آوردن بزرگترین مقسوم علیه مشترک دو عدد}\label{ch1:alg:gcd}
\begin{latin}
\begin{algorithmic}[1]
\Function{GCD}{$m,n$}		
		\If{$m < n$}
				\State \bcall{Swap}{$m,n$}
		\EndIf
		\If{$n \isequal 0$}
			\State \Return $m$
		\Else
			\State \Return \bcall{GCD}{$n, m\bmod n$}
		\EndIf
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\پاسخ

تعداد اعمال {$\bmod$} انجام شده در الگوریتم {\eqref{ch1:alg:gcd}} را با {$T(m,n)$} نشان می‌دهیم. حالت پایه‌‌ی رابطه‌‌ی بازگشتی هنگامی است که {$n$} برابر با صفر باشد که در این صورت تعداد اعمال {$\bmod$} انجام شده برابر با صفر خواهد بود. یعنی داریم:
\begin{equation}
T(m,n)=0\label{ch1:eqn:gcdBaseCase}
\end{equation}
در صورتیکه {$n$} بزرگتر از صفر باشد آنگاه ابتدا یک عمل {$\bmod$} انجام شده و سپس دوباره الگوریتم با مقادیر جدید فراخوانی می‌شود. برای این حالت خواهیم داشت:
\begin{equation}
T(m,n)=1+T(n, m \bmod n)\label{ch1:eqn:gcdRecCase}
\end{equation}
با ترکیب روابط {\eqref{ch1:eqn:gcdBaseCase}} و {\eqref{ch1:eqn:gcdRecCase}} به رابطه‌ی بازگشتی {\eqref{ch1:eqn:gcd}} می‌رسیم که نشان‌دهنده‌ی تعداد اعمال {$\bmod$} انجام شده در الگوریتم {\eqref{ch1:alg:gcd}} است.
\begin{equation}
T(m,n) =
\begin{cases}
0 & \quad n=0\\
1+T(n,m\bmod n) & \quad n>0
\end{cases}\label{ch1:eqn:gcd}
\end{equation}

\سوال مرتبه‌ی رابطه‌ی بازگشتی زیر را به دست آورید (راهنمایی: کار را با تقسیم طرفین بر {$n$} شروع کنید).
\begin{displaymath}
T(n)=
\begin{cases}
\Theta (1) & n=1\\
\sqrt{n}\,T\left(\sqrt{n}\,\right)+n & n>1
\end{cases}
\end{displaymath}

\پاسخ

ابتدا طرفین رابطه‌ی {$T(n)=\sqrt{n}\,T(\sqrt{n}\,)+n$} را بر {$n$} تقسیم می‌کنیم که در این صورت داریم:
\begin{equation}
\dfrac{T(n)}{n}=\dfrac{T(\sqrt{n}\,)}{\sqrt{n}}+1\label{ch1:eqn:rec1TdivN}
\end{equation}
اگر قرار دهیم {$H(n)=T(n)/n$} آنگاه می‌توان رابطه‌ی بازگشتی {\eqref{ch1:eqn:rec1TdivN}} را به صورتی که در ادامه آمده است بازنویسی کرد:
\begin{equation}
H(n)=H(\sqrt{n}\,)+1\label{ch1:eqn:rec1VarChg}
\end{equation}
با در نظر گرفتن تغییر متغیر {$n=2^k$} می‌توان رابطه‌ی بازگشتی {\eqref{ch1:eqn:rec1VarChg}} را به شکل {\eqref{ch1:eqn:rec1FunChg}} نوشت:
\begin{equation}
H\left(2^k\right)=H\left(2^{k/2}\right)+1\label{ch1:eqn:rec1FunChg}
\end{equation}
اگر قرار دهیم {$S(k)=H(2^k)$} آنگاه می‌توان رابطه‌ی {\eqref{ch1:eqn:rec1FunChg}} را به شکل زیر در نظر گرفت:
\begin{displaymath}
S(k)=S\left(\dfrac{k}{2}\right)+1
\end{displaymath}
{$S(k)$} دارای فرم کلی یک رابطه‌ی تقسیم و غلبه\پانویس{{\lr{Divide and conquer}}} است پس با استفاده از قضیه‌ی اصلی\پانویس{{\lr{Master theorem}}} و حالت دوم این قضیه می‌توان نتیجه گرفت:
\begin{displaymath}
S(k)=\Theta( \lg k )
\end{displaymath}
اگر به جای {$S(k)$}، معادل آن یعنی {$H(2^k)$} را قرار دهیم داریم:
\begin{equation}
H(2^k)=\Theta( \lg k )\label{ch1:eqn:rec1RevFunChg}
\end{equation}
با در نظر گرفتن رابطه‌ی {$n=2^k$} می‌توان نتیجه گرفت {$\lg \lg n=\lg k$}. با جایگذاری {$\lg \lg n$} به جای {$\lg k$} در {\eqref{ch1:eqn:rec1RevFunChg}} داریم:
\begin{displaymath}
H(n)=\Theta( \lg \lg n )
\end{displaymath}
اگر به جای {$H(n)$}، معادل آن یعنی {$T(n)/n$} را قرار دهیم به رابطه‌ی زیر می‌رسیم:
\begin{displaymath}
\dfrac{T(n)}{n} =\Theta( \lg \lg n ) \Rightarrow T(n)=n\cdot \Theta( \lg \lg n ) \Rightarrow T(n)=\Theta( n\lg \lg n )
\end{displaymath}
به این ترتیب می‌توان گفت {$T(n)$} از مرتبه‌ی {$\Theta(n\lg \lg n)$} است.

\سوال نشان دهید رابطه‌ی بازگشتی زیر از مرتبه‌ی {$O(n)$} است.
\begin{displaymath}
\quad T(n)=
\begin{cases}
\Theta (1) & n=1\\[0.3cm]
T\left(\dfrac{n}{2}\right)+T\left(\dfrac{n}{4}\right)+T\left(\dfrac{n}{8}\right)+n & n>1
\end{cases}
\end{displaymath}

\پاسخ

برای به دست آوردن یک حدس مناسب برای مرتبه‌ی رابطه‌ی بازگشتی {$T(n)=T(n/2)+T(n/4)+T(n/8)+n$} از درخت بازگشت استفاده می‌کنیم. سپس با استفاده از روش جانشینی\پانویس{{\lr{Substitution method}}} نشان می‌دهیم که حدس به دست آمده یک حدس درست است.
\begin{figure}
\begin{center}
\scalebox{0.7}
{
\begin{pspicture}(0,-3.4296875)(13.396563,3.4296875)
\psline[linewidth=0.02cm](6.4290624,2.9271874)(1.8490624,1.8071876)
\psline[linewidth=0.02cm](6.6290627,2.9471874)(6.6290627,1.7471875)
\psline[linewidth=0.02cm](6.8490624,2.9271874)(11.409062,1.8071876)
\psline[linewidth=0.02cm](1.7634503,0.7088264)(0.2490625,-0.39283663)
\psline[linewidth=0.02cm](1.8287256,0.7271875)(1.8287256,-0.37447557)
\psline[linewidth=0.02cm](1.9005284,0.7088264)(3.4090624,-0.3728125)
\psline[linewidth=0.02cm](6.5834503,0.7088264)(5.0690627,-0.39283663)
\psline[linewidth=0.02cm](6.6487255,0.7271875)(6.6487255,-0.37447557)
\psline[linewidth=0.02cm](6.7205286,0.7088264)(8.249063,-0.3728125)
\psline[linewidth=0.02cm](11.40345,0.66882646)(9.889063,-0.43283662)
\psline[linewidth=0.02cm](11.468725,0.6871875)(11.468725,-0.4144756)
\psline[linewidth=0.02cm](11.540528,0.66882646)(13.069062,-0.4128125)
\usefont{T1}{ptm}{m}{n}
\rput(6.656875,3.2221874){$n$}
\rput(1.8304688,1.1971875){$\dfrac{n}{2}$}
\rput(6.6317186,1.1971875){$\dfrac{n}{4}$}
\rput(11.447657,1.1971875){$\dfrac{n}{8}$}
\rput(0.27171874,-0.8628125){$\dfrac{n}{4}$}
\rput(1.8076563,-0.8628125){$\dfrac{n}{8}$}
\rput(3.3610938,-0.8628125){$\dfrac{n}{16}$}
\rput(5.087656,-0.8628125){$\dfrac{n}{8}$}
\rput(6.6410937,-0.8628125){$\dfrac{n}{16}$}
\rput(8.2604685,-0.8628125){$\dfrac{n}{32}$}
\rput(9.8610935,-0.8628125){$\dfrac{n}{16}$}
\rput(11.460468,-0.8628125){$\dfrac{n}{32}$}
\rput(13.0417185,-0.8628125){$\dfrac{n}{64}$}
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](0.2290625,-1.4128125)(0.2290625,-2.9728124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](1.8290625,-1.4128125)(1.8290625,-2.9728124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](3.3290625,-1.3928125)(3.3290625,-2.9528124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](5.0690627,-1.4528126)(5.0690627,-3.0128126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](6.6690626,-1.4528126)(6.6690626,-3.0128126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](8.189062,-1.4328125)(8.189062,-2.9928124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](9.889063,-1.3928125)(9.889063,-2.9528124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](11.489062,-1.3928125)(11.489062,-2.9528124)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](12.989062,-1.3728125)(12.989062,-2.9328125)
\rput(0.30609375,-3.3428125){$T(1)$}
\rput(3.3060937,-3.3428125){$T(1)$}
\rput(5.066094,-3.3428125){$T(1)$}
\rput(6.646094,-3.3428125){$T(1)$}
\rput(8.166094,-3.3428125){$T(1)$}
\rput(9.906094,-3.3428125){$T(1)$}
\rput(11.5260935,-3.3428125){$T(1)$}
\rput(12.9860935,-3.3428125){$T(1)$}
\rput(1.8260938,-3.3428125){$T(1)$}
\usefont{T1}{ptm}{m}{n}
\rput(14.857187,3.1934376){$n$}
\rput(14.940938,1.2134376){$\left(\dfrac{7}{8}\right)n$}
\rput(14.970937,-0.8865625){${\left(\dfrac{7}{8}\right)}^2n$}
\rput(14.795156,-3.3365625){$O(n)$}
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](14.729062,-1.5565625)(14.729062,-2.8165626)
\end{pspicture} 
}\caption{درخت بازگشت رابطه‌ی بازگشتی {$T(n)=T(n/2)+T(n/4)+T(n/8)+n$}}\label{ch1:fig:T1RecTree}
\end{center}
\end{figure}

درخت بازگشت رابطه‌ی بازگشتی {$T(n)=T(n/2)+T(n/4)+T(n/8)+n$} در شکل {\eqref{ch1:fig:T1RecTree}} نشان داده شده است. هزینه‌ی هر سطح از درخت در سمت راست آن سطح نوشته شده است. با توجه به این شکل، مسیر زیر دارای بیشترین طول در درخت است و در نتیجه ارتفاع درخت بازگشت توسط این مسیر تعیین می‌شود.
\begin{displaymath}
n \rightarrow \frac{n}{2} \rightarrow \frac{n}{4} \rightarrow \frac{n}{8} \rightarrow \cdots \rightarrow \frac{n}{2^i} \rightarrow \cdots \rightarrow 1
\end{displaymath}
برای تعیین ارتفاع درخت باید دید چه زمانی عبارت {$n/2^i$} برابر با یک می‌شود. اگر قرار دهیم {$n/2^i=1$} آنگاه می‌توان گفت {$i=\lg n$} و این یعنی ارتفاع درخت برابر با {$\lg n$} است. 

با توجه به ارتفاع درخت می‌توان گفت تعداد سطوح درخت برابر با {$\lg n + 1$} است (از سطح یک تا سطح {$\lg n + 1$}). از طرفی هزینه‌ی هر سطح (به جز سطح آخر) از رابطه‌ی {${(7/8)}^{i-1}n$} پیروی می‌کند که در آن {$i$} شماره‌ی سطح است. هزینه‌ی سطح آخر از فرمول کلی هزینه‌ی یک سطح پیروی نمی‌کند زیرا هزینه‌ی گره‌ای در سطح آخر نشان‌دهنده‌ی حالت پایه‌ی رابطه بازگشتی است و در نتیجه هزینه‌ی سطح آخر باید به صورت جداگانه محاسبه شود. اگر سطح آخر دارای حداکثر تعداد گره یعنی {$3^{\lg n}$} (معادل با {$n^{\lg 3}$}) گره باشد چون هزینه‌ی هر گره {$\Theta (1)$} است در نتیجه هزینه‌ی سطح آخر برابر با {$O(n^{\lg 3})$} خواهد بود. اما از آنجایی که سطح آخر دارای حداکثر تعداد گره نیست در نتیجه هزینه‌ی این سطح کمتر از {$O(n^{\lg 3})$} است. در ادامه، هزینه‌ی سطح آخر را {$O(n)$} در نظر می‌گیریم.

پس از به دست آوردن تعداد سطوح و هزینه‌ی هر سطح می‌توان به محاسبه‌ی هزینه‌‌ی کلی درخت بازگشت پرداخت که این هزینه بیانگر مرتبه‌ی رابطه‌ی بازگشتی است. هزینه‌ی درخت بازگشت توسط رابطه‌ی {\eqref{ch1:eqn:rec2Tn}} بیان می‌شود.
\begin{equation}
T(n)=O(n) + \sum_{i=1}^{\lg n}{{\biggl( \frac{7}{8} \biggr)}^{i-1}n}\label{ch1:eqn:rec2Tn}
\end{equation}
رابطه‌ی {\eqref{ch1:eqn:rec2Tn}} را می‌توان به صورتی که در ادامه آمده است ساده کرد:
\begin{align*}
T(n) &= O(n) + \sum_{i=0}^{\lg n - 1}{{\biggl( \frac{7}{8} \biggr)}^{i}n}\\
		&\leq O(n) + \sum_{i=0}^{\infty}{{\biggl( \frac{7}{8} \biggr)}^in}\\
		&= O(n) + n\cdot\frac{1}{1-\frac{7}{8}}\\
		&= O(n) + 8n
\end{align*}
به این ترتیب حدس می‌زنیم {$T(n)$} از مرتبه‌ی {$O(n)$} باشد. در ادامه نشان می‌دهیم حدس زده شده یک حدس مناسب است.

فرض می‌کنیم رابطه‌ی {$T(k)\leqslant ck$}، که در آن {$c$} یک مقدار ثابت غیرمنفی است، برای هر {$k<n$} برقرار باشد. نشان می‌دهیم رابطه‌ی {$T(k)\leqslant ck$} برای {$k=n$} نیز برقرار است.

چون رابطه‌ی {$T(k)\leqslant ck$} برای مقادیر کمتر از {$n$}  برقرار است و از طرفی {$n/2$}، {$n/4$} و {$n/8$} هر سه کمتر از {$n$} هستند پس روابط {\eqref{ch1:eqn:T2TnOver2}}، {\eqref{ch1:eqn:T2TnOver4}} و {\eqref{ch1:eqn:T2TnOver8}} برقرار هستند.
\begin{equation}
T\left(\frac{n}{2}\right) \leq \frac{cn}{2}\label{ch1:eqn:T2TnOver2}
\end{equation}
\begin{equation}
T\left(\frac{n}{4}\right) \leq \frac{cn}{4}\label{ch1:eqn:T2TnOver4}
\end{equation}
\begin{equation}
T\left(\frac{n}{8}\right) \leq \frac{cn}{8}\label{ch1:eqn:T2TnOver8}
\end{equation}

با جایگذاری {\eqref{ch1:eqn:T2TnOver2}}، {\eqref{ch1:eqn:T2TnOver4}} و {\eqref{ch1:eqn:T2TnOver8}} در رابطه‌ی بازگشتی و ساده‌سازی خواهیم داشت:
\begin{align*}
T(n) &\leq \frac{cn}{2} + \frac{cn}{4} + \frac{cn}{8} + n\\
	 &= \frac{7cn}{8} + n\\
	 &= \frac{7cn}{8} + \frac{cn}{8} - \frac{cn}{8} + n\\
	 &= cn - \frac{cn}{8} + n\\
	 &= cn - \left(\frac{cn}{8} - n\right)
\end{align*}
حال باید مقدار ثابت {$c$} را طوری تعیین کنیم که داشته باشیم {$(cn/8) - n \geqslant 0$} تا بتوانیم نتیجه بگیریم {$T(n) \leqslant cn$}. مقدار {$c$} به صورت زیر به دست می‌آید:
\begin{displaymath}
\frac{cn}{8} - n \geq 0 \Rightarrow \frac{cn}{8} \geq n \Rightarrow cn \geq 8n \Rightarrow c \geq 8
\end{displaymath}
به این ترتیب ثابت کردیم رابطه‌ی بازگشتی {$T(n)=T(n/2)+T(n/4)+T(n/8)+n$} از مرتبه‌ی {$O(n)$} است.

\سوال رابطه‌ی بازگشتی زیر از چه مرتبه‌ای است؟
\begin{displaymath}
T(n)=
\begin{cases}
\Theta (1) & n=1\\[0.3cm]
5T\left(\dfrac{n}{5}\right)+\dfrac{n}{\log_5{n}} & n>1
\end{cases}
\end{displaymath}

\پاسخ

برای به دست آوردن مرتبه‌ی این رابطه‌ی بازگشتی از روش تکرار با جایگزینی استفاده می‌کنیم. می‌توان {$T(n)=5T(n/5)+n/\log_5 n$} را به صورت زیر بسط داد:
\begin{align}
T(n) &=5T\left( \frac{n}{5}\right)+\frac{n}{\log_5{n}}\nonumber\\[0.3cm]
		&=5^2T\left( \frac{n}{5^2}\right)+\frac{n}{\log_5{n}}+\frac{n}{\log_5(n/5)}\nonumber\\[0.3cm]
		&=5^3T\left( \frac{n}{5^3}\right)+\frac{n}{\log_5{n}}+\frac{n}{\log_5(n/5)}+\frac{n}{\log_5{(n/5^2)}} \nonumber\\
		&=\qquad \vdots\nonumber\\
		&= 5^kT\left( \frac{n}{5^k}\right)+\frac{n}{\log_5{n}}+\frac{n}{\log_5{(n/5)}}+\frac{n}{\log_5{(n/5^2)}}+ \cdots +\frac{n}{\log_5{(n/5^{k-1})}}\nonumber\\[0.3cm]
		&= 5^kT\left( \frac{n}{5^k}\right) + \sum_{i=0}^{k-1}{\frac{n}{\log_5{(n/5^i)}}}\label{ch1:eqn:rec3Tn}
\end{align}
اگر فرض کنیم {$n=5^k$} آنگاه داریم {$k=\log_5{n}$}. با قرار دادن {$\log_5{n}$} به جای {$k$} در {\eqref{ch1:eqn:rec3Tn}} خواهیم داشت:
\begin{align*}
T(n) &= 5^{\log_5{n}}T(1)+\sum_{i=0}^{\log_5{n}-1}{\frac{n}{\log_5{(n/5^i)}}}\\
		&= nT(1)+n\sum_{i=0}^{\log_5{n}-1}{\frac{1}{\log_5 n - \log_5 5^i}}\\
		&= n\Theta (1)+n\sum_{i=0}^{\log_5{n}-1}{\frac{1}{\log_5{n}-i}}\\
		&= n\Theta (1)+n\sum_{i=1}^{\log_5{n}}{\frac{1}{i}}\\
		&= n\Theta (1)+n\lg {\log_5{n}}\\
		&= \Theta (n)+n\lg {\log_5{n}}
\end{align*}
بدین ترتیب نشان دادیم {$T(n)= \Theta (n)+n\lg {\log_5{n}}$}. از آنجایی که پایه‌ی لگاریتم در مرتبه‌ اهمیت ندارد در نتیجه می‌توان گفت {$T(n)$} از مرتبه‌ی {$\Theta(n\lg {\lg{n}})$} است.

\سوال مرتبه‌ی رابطه‌ی بازگشتی زیر را تعیین کنید.
\begin{displaymath}
T(n)=
\begin{cases}
\Theta (1) & n=1\\[0.3cm]
T\left(\dfrac{n}{3}\right)+ T\left(\dfrac{2n}{3}\right) + cn & n>1
\end{cases}
\end{displaymath}

\پاسخ

درخت بازگشت رابطه‌ی بازگشتی {$T(n)=T(n/3)+T(2n/3)+cn$} در شکل {\eqref{ch1:fig:T2recTree}} نشان داده شده است.
\begin{figure}
\begin{center}
\scalebox{0.7} 
{
\begin{pspicture}(0,-3.3796875)(8.095312,3.3796875)
\psline[linewidth=0.02cm](3.8490624,2.9571874)(1.8290625,2.0371876)
\psline[linewidth=0.02cm](4.2690625,2.9571874)(6.2690625,2.0171876)
\psline[linewidth=0.02cm](1.7634503,1.0388265)(0.2490625,-0.06283663)
\psline[linewidth=0.02cm](1.9005284,1.0388265)(3.4090624,-0.0428125)
\psline[linewidth=0.02cm](6.1434503,1.0588264)(4.6290627,-0.04283663)
\psline[linewidth=0.02cm](6.2805285,1.0588264)(7.7890625,-0.0228125)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](4.6090627,-1.2028126)(4.6090627,-2.7628126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](7.7090626,-1.2028126)(7.7090626,-2.7628126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](0.2290625,-1.2028126)(0.2290625,-2.7628126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](3.3290625,-1.2028126)(3.3290625,-2.7628126)
\usefont{T1}{ptm}{m}{n}
\rput(4.076875,3.1721875){$cn$}
\rput(1.8304688,1.5271875){$\dfrac{cn}{3}$}
\rput(6.210469,1.5471874){$\dfrac{2cn}{3}$}
\rput(0.27171874,-0.5328125){$\dfrac{cn}{9}$}
\rput(3.3610938,-0.5528125){$\dfrac{2cn}{9}$}
\rput(4.6517186,-0.5128125){$\dfrac{2cn}{9}$}
\rput(7.7410936,-0.5328125){$\dfrac{4cn}{9}$}
\rput(0.30609375,-3.1528125){$T(1)$}
\rput(3.3060937,-3.1328125){$T(1)$}
\rput(4.686094,-3.1328125){$T(1)$}
\rput(7.686094,-3.1128125){$T(1)$}
%\rput(9.58,3.7934374){\rl{سطح}}
%\rput(10.8332815,3.7934374){\rl{هزینه}}
%\rput(9.535937,3.1734376){$1$}
\rput(9.857187,3.184376){$cn$}
%\rput(9.547656,1.5134375){$2$}
\rput(9.857187,1.5104375){$cn$}
%\rput(9.536718,-0.4065625){$3$}
\rput(9.857187,-0.4065625){$cn$}
\rput(9.775156,-3.1128125){$O(n)$}
%\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](9.535937,-1.2028126)(9.535937,-2.7628126)
\psline[linewidth=0.04cm,linestyle=dotted,dotsep=0.25cm](9.857187,-1.2028126)(9.857187,-2.7628126)
\end{pspicture} 
}\caption{درخت بازگشت رابطه‌ی بازگشتی {$T(n)=T(n/3)+T(2n/3)+cn$}}\label{ch1:fig:T2recTree}
\end{center}
\end{figure}

با توجه به شکل {\eqref{ch1:fig:T2recTree}}، مسیر زیر دیرتر از سایر مسیرها به {$T(1)$} (که همان شرط توقف رابطه‌ی بازگشتی است) می‌رسد. در نتیجه از این مسیر می‌توان برای تعیین ارتفاع درخت بازگشت و تخمین سقف رابطه‌ی بازگشتی استفاده کرد. 
\begin{displaymath}
cn \rightarrow \frac{2cn}{3} \rightarrow \frac{4cn}{9} \rightarrow \frac{8cn}{27} \rightarrow \cdots \rightarrow \frac{2^icn}{3^i} \rightarrow \cdots \rightarrow 1
\end{displaymath}
با توجه به مسیر فوق می‌توان گفت ارتفاع درخت بازگشت برابر با {$\log_{3/2}{n}$} است. همچنین هزینه‌ی هر سطح از این درخت برابر با {$cn$} است. 

با توجه به اینکه حداکثر ارتفاع درخت بازگشت و هزینه‌ی هر سطح از این درخت را داریم یک حدس مناسب برای مرتبه‌ی این رابطه‌ی بازگشتی می‌تواند {$O(n\log_{3/2}{n})$} باشد. چون به ازای هر دو عدد غیرمنفی {$a$} و {$b$} داریم {$O(\log_{a}{n})=O(\log_{b}{n})$} پس {$O(n\log_{3/2}{n})$} معادل با {$O(n\lg n)$} است. در ادامه نشان می‌دهیم {$O(n\lg n)$} سقف مناسبی برای رابطه‌ی بازگشتی {$T(n)=T(n/3)+T(2n/3)+cn$} است.

فرض می‌کنیم رابطه‌ی {$T(k)\leqslant d k\lg k$}، که در آن {$d$} یک مقدار ثابت غیرمنفی است، برای هر {$k<n$} برقرار باشد. نشان می‌دهیم که این رابطه برای {$k=n$} نیز برقرار است.

چون رابطه‌ی {$T(k)\leqslant d k\lg k$} برای مقادیر کمتر از {$n$}  برقرار است و از طرفی {$n/3$} و {$2n/3$} هر دو کمتر از {$n$} هستند پس روابط {\eqref{ch1:eqn:rec4Tn3}} و {\eqref{ch1:eqn:rec4T2n3}} نیز برقرارند.
\begin{align}
T\left(\frac{n}{3}\right) &\leq d\frac{n}{3}\lg \frac{n}{3}\label{ch1:eqn:rec4Tn3}\\
T\left(\frac{2n}{3}\right) &\leq d\frac{2n}{3}\lg \frac{2n}{3}\label{ch1:eqn:rec4T2n3}
\end{align}
با جایگذاری {\eqref{ch1:eqn:rec4Tn3}} و {\eqref{ch1:eqn:rec4T2n3}}} در {$T(n)=T(n/3)+T(2n/3)+cn$} داریم:
\begin{align*}
T(n) &\leq \left( d\frac{n}{3}\lg \frac{n}{3} \right) + \left( d\frac{2n}{3}\lg \frac{2n}{3} \right) + cn\\
		&= \left( d\frac{n}{3}\lg n - d\frac{n}{3}\lg 3 \right) + \left( d\frac{2n}{3}\lg n - d\frac{2n}{3}\lg \frac{3}{2}\right) + cn \\
		&= dn\lg n - d \left( \frac{n}{3}\lg 3 + \frac{2n}{3}\lg \frac{3}{2} \right) + cn \\		
		&= dn\lg n - d \left( \frac{n}{3}\lg 3 + \frac{2n}{3}\lg 3 - \frac{2n}{3}\lg 2 \right) + cn \\		
		&= dn\lg n - dn \left( \lg 3 - \frac{2}{3} \right) + cn\\
		&= dn\lg n - \left(dn \left( \lg 3 - \frac{2}{3} \right) - cn \right)
\end{align*}
در این مرحله باید مقدار ثابت {$d$} را طوری تعیین کنیم که عبارت {$dn( \lg 3 - (2/3)) - cn$} بزرگتر یا مساوی صفر باشد تا بتوانیم نتیجه بگیریم {$T(n)\leqslant dn\lg n$}. مقدار {$d$} به صورت زیر به دست می‌آید:
\begin{align*}
dn \left( \lg 3 - \frac{2}{3} \right) - cn \geq 0 \Rightarrow dn \geq \frac{cn}{\lg 3 - \frac{2}{3}} \Rightarrow d \geq \frac{c}{\lg 3 - \frac{2}{3}}
\end{align*}
پس کافیست ثابت {$d$} را طوری انتخاب کنیم که رابطه‌ی {$d \geqslant c/(\lg 3 - (2/3))$} برقرار باشد.

به این ترتیب نشان دادیم رابطه‌ی بازگشتی {$T(n)=T(n/3)+T(2n/3)+cn$} از مرتبه‌ی {$O(n\lg n)$} است.

\سوال رابطه‌ی بازگشتی {$T(n)=8T(n/2)+2n^3{\lg}^2 n+3n^3$} از چه مرتبه‌ای است؟

\پاسخ

برای به دست آوردن مرتبه‌ی رابطه‌ی بازگشتی {$T(n)=8T(n/2)+2n^3{\lg}^2 n+3n^3$} می‌توان از حالت خاص قضیه‌ی اصلی استفاده کرد. حالت خاص قضیه‌ی اصلی در ادامه آمده است.

در رابطه‌ی بازگشتی {$T(n)=aT(n/b)+f(n)$} که در آن {$a\geqslant 1$} و {$b>1$} مقادیر ثابت هستند اگر داشته باشیم
 {$f(n)=\Theta (n^{\log_b a}{\lg}^k n)$} آنگاه مرتبه‌ی رابطه‌ی بازگشتی {$T(n)$} برابر با {$\Theta (n^{\log_b a}{\lg}^{k+1} n)$} خواهد بود.

با در نظر گرفتن رابطه‌ی بازگشتی {$T(n)=8T(n/2)+2n^3{\lg}^2 n+3n^3$} داریم {$a=8$}، {$b=2$}، {$n^{\log_b a}=n^3$} و {$f(n)=2n^3{\lg}^2 n+3n^3$}. با توجه به حالت خاص قضیه‌ی اصلی چون رابطه‌ی {$2n^3{\lg}^2 n+3n^3=\Theta (n^3{\lg}^2 n)$} برقرار است در نتیجه می‌توان گفت {$T(n)$} از مرتبه‌ی {$\Theta (n^3{\lg}^3 n)$} است.

\سوال مرتبه‌ی رابطه‌ی بازگشتی زیر را به دست آورید.
\begin{displaymath}
T(n)=
\begin{cases}
1 & n=0\\
{\displaystyle\sum_{i=0}^{n-1}{T(i)} + 1} & n>0
\end{cases}
\end{displaymath}

\پاسخ

با توجه به تعریف رابطه‌ی بازگشتی {$T(n)$}، برای حالت {$n=0$} داریم:
\begin{displaymath}
T(0)=1
\end{displaymath}
از مقدار {$T(0)$} می‌توان مقدار {$T(1)$} را به صورت زیر به دست آورد:
\begin{displaymath}
T(1)=T(0) + 1
\end{displaymath}
با در نظر گرفتن مقدار {$T(1)$}، مقدار {$T(2)$} به صورتی که در ادامه آمده است خواهد بود:
\begin{displaymath}
T(2)=T(0) + T(1) + 1 = 2T(0) + 1 + 1
\end{displaymath}
از مقدار {$T(2)$}، می‌توان مقدار {$T(3)$} را به صورت زیر به دست آورد:
\begin{displaymath}
T(3)=T(0) + T(1) + T(2) + 1 = 4T(0) + 1 + 1 + 1 + 1
\end{displaymath}
اگر همین روند را ادامه دهیم مقدار {$T(n)$} به صورت زیر به دست می‌آید:
\begin{displaymath}
T(n) = T(0) + T(1) + T(2) + \cdots + T(n-1) + 1= 2^{n-1}T(0) + 2^{n-1}
\end{displaymath}

اگر در رابطه‌ی {$T(n)=2^{n-1}T(0) + 2^{n-1}$} به جای {$T(0)$} مقدار معادل آن یعنی ۱ را قرار دهیم به رابطه‌ی {$T(n)=2^{n}$} می‌رسیم و به این ترتیب می‌توان نتیجه گرفت {$T(n)$} از مرتبه‌ی {$\Theta (2^{n})$} است.


\قسمت{تحلیل مرتبه‌ی زمانی الگوریتم‌ها}

\سوال عدد صحیح {$m$} و آرایه‌ی {$A$} که حاوی اعداد صحیح است را در نظر بگیرید. الگوریتمی بنویسید که اگر تعداد اعداد بزرگتر یا مساوی {$m$} در آرایه‌ی {$A$}، بیشتر یا مساوی با تعداد اعداد کوچکتر از {$m$} است مقدار {\const{true}} و در غیر اینصورت مقدار {\const{false}} را به عنوان خروجی برگرداند. بهترین و بدترین حالت در اجرای این الگوریتم در چه صورتی رخ می‌دهد؟ الگوریتم خود را، در صورت لزوم، به گونه‌ای تغییر دهید که به محض تشخیص جواب، اجرای آن خاتمه یابد.

\پاسخ

شبه کد الگوریتم مورد نظر در قالب الگوریتم {\eqref{ch1:alg:moreOrLess}} نشان داده شده است. الگوریتم ارائه ‌شده به درستی کار می‌کند اما بدترین و بهترین حالت اجرای آن یکسان است. این بدین معنی است که حلقه‌ی موجود در این الگوریتم همواره {$n$} بار تکرار می‌شود. 

\begin{algorithm}
\caption{شمارش اعداد بزرگتر یا کوچکتر از یک مقدار خاص}\label{ch1:alg:moreOrLess}
\begin{latin}
\begin{algorithmic}[1]
\Function{MoreOrLess}{$A,m$}
	\State $g \gets 0$
	\State $l \gets 0$
	\State $n \gets \attrib{A}{length}$
	\For{$i \gets 1 \To n$}
 			\If{$A[i] \geq m$}
					\State	$g \gets g+1$
			\Else
					\State $l \gets l+1$
			\EndIf
	\EndFor
	\If{$g \geq l$}
			\State \Return \const{true}
	\Else
			\State \Return \const{false}
	\EndIf
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

در الگوریتم {\eqref{ch1:alg:moreOrLess}} بهترین حالت زمانی رخ می‌دهد که اعداد موجود در نیمه‌ی ابتدایی آرایه‌ی {$A$} بزرگتر یا مساوی با عدد {$m$} باشند. به طور مثال برای آرایه‌ای هشت خانه‌ای و {$m=10$}، یکی از بهترین حالت‌ها می‌تواند مانند آرایه‌ی نشان داده شده در شکل {\eqref{ch1:fig:moreLessBest}} باشد. در این صورت خروجی الگوریتم بعد از ارزیابی مقدار ۲۲ کاملاً مشخص خواهد شد و تکرارهای بعدی حلقه تاثیری بر خروجی الگوریتم ندارد.

یکی از بدترین حالات در اجرای الگوریتم {\eqref{ch1:alg:moreOrLess}} زمانی است که اعداد آرایه‌ی {$A$} به صورت یکی در میان بزرگتر و کوچکتر از عدد {$m$} باشند. در این صورت الگوریتم برای رسیدن به جواب باید تمام عناصر آرایه‌ی {$A$} را مورد بررسی قرار دهد. به عنوان مثال برای آرایه‌ای با هشت عنصر و {$m=10$}، یکی از بدترین حالات می‌تواند به صورت نشان داده شده در شکل {\eqref{ch1:fig:moreLessWorst}} باشد.

\begin{figure}
\begin{center}
\scalebox{0.8} 
{
\begin{pspicture}(0,-0.63875)(8.04,0.67875)
\psframe[linewidth=0.04,dimen=outer](8.04,0.16125)(0.0,-0.63875)
\psline[linewidth=0.04cm](0.98,0.12125)(0.98,-0.59875)
\psline[linewidth=0.04cm](1.98,0.12125)(1.98,-0.59875)
\psline[linewidth=0.04cm](2.98,0.12125)(2.98,-0.59875)
\psline[linewidth=0.04cm](3.98,0.12125)(3.98,-0.59875)
\psline[linewidth=0.04cm](5.0,0.12125)(5.0,-0.59875)
\psline[linewidth=0.04cm](6.0,0.12125)(6.0,-0.59875)
\psline[linewidth=0.04cm](7.0,0.12125)(7.0,-0.59875)
\usefont{T1}{ptm}{m}{n}
\rput(0.47734374,0.47625){$1$}
\rput(1.49625,0.47625){$2$}
\rput(2.5028124,0.47625){$3$}
\rput(3.4989061,0.47625){$4$}
\rput(4.485,0.45625){$5$}
\rput(5.512031,0.45625){$6$}
\rput(6.492031,0.45625){$7$}
\rput(7.4840627,0.45625){$8$}
\rput(0.46515626,-0.26375){\large $12$}
\rput(1.4451562,-0.26375){\large $12$}
\rput(2.4465625,-0.26375){\large $14$}
\rput(3.48625,-0.26375){\large $22$}
\rput(4.4773436,-0.24375){\large $1$}
\rput(5.51625,-0.24375){\large $2$}
\rput(6.4828124,-0.26375){\large $3$}
\rput(7.537031,-0.26375){\large $23$}
\end{pspicture} 
}\caption{یکی از بهترین ورودی‌ها برای الگوریتم {\eqref{ch1:alg:moreOrLess}}}\label{ch1:fig:moreLessBest}
\end{center}
\end{figure}

\begin{figure}
\begin{center}
\scalebox{0.8}
{
\begin{pspicture}(0,-0.62875)(8.04,0.66875)
\psframe[linewidth=0.04,dimen=outer](8.04,0.17125)(0.0,-0.62875)
\psline[linewidth=0.04cm](0.98,0.13125)(0.98,-0.58875)
\psline[linewidth=0.04cm](1.98,0.13125)(1.98,-0.58875)
\psline[linewidth=0.04cm](2.98,0.13125)(2.98,-0.58875)
\psline[linewidth=0.04cm](3.98,0.13125)(3.98,-0.58875)
\psline[linewidth=0.04cm](5.0,0.13125)(5.0,-0.58875)
\psline[linewidth=0.04cm](6.0,0.13125)(6.0,-0.58875)
\psline[linewidth=0.04cm](7.0,0.13125)(7.0,-0.58875)
\usefont{T1}{ptm}{m}{n}
\rput(0.47734374,0.46625){$1$}
\rput(1.49625,0.46625){$2$}
\rput(2.5028124,0.46625){$3$}
\rput(3.4989061,0.46625){$4$}
\rput(4.485,0.46625){$5$}
\rput(5.512031,0.46625){$6$}
\rput(6.492031,0.46625){$7$}
\rput(7.4840627,0.46625){$8$}
\rput(0.47703126,-0.25375){\large $23$}
\rput(1.511875,-0.25375){\large $9$}
\rput(2.4796875,-0.25375){\large $15$}
\rput(3.491875,-0.25375){\large $9$}
\rput(4.485781,-0.23375){\large $16$}
\rput(5.5040627,-0.23375){\large $8$}
\rput(6.465156,-0.23375){\large $12$}
\rput(7.5228124,-0.27375){\large $3$}
\end{pspicture} 
}\caption{یکی از بدترین ورودی‌های ممکن برای الگوریتم {\eqref{ch1:alg:moreOrLess}}}\label{ch1:fig:moreLessWorst}
\end{center}
\end{figure}

با توجه به توضیحات ارائه ‌شده شبه کد الگوریتم تغییر یافته در الگوریتم {\eqref{ch1:alg:btrMoreOrLess}} آورده شده است. زوج یا فرد بودن تعداد خانه‌های آرایه در این الگوریتم مهم است و به همین جهت در این الگوریتم از تابع سقف استفاده شده است.

\begin{algorithm}[t]
\caption{شمارش اعداد بزرگتر یا کوچکتر از یک مقدار خاص}
\label{ch1:alg:btrMoreOrLess}
\begin{latin}
\begin{algorithmic}[1]
\Function{ModifiedMoreOrLess}{$A,m$}
	\State $g \gets 0$
	\State $l \gets 0$
	\State $n \gets \attrib{A}{length}$
	\For{$i \gets 1 \To n$}	 	
%	\algstore{btrMoreOrLessBrk}	
%\end{algorithmic}
%\end{latin}
%\end{algorithm}
%
%\begin{algorithm}
%\caption{شمارش اعداد بزرگتر یا کوچکتر از مقدار ورودی - ادامه}
%\begin{latin}
%\begin{algorithmic}[1]
%			\algrestore{btrMoreOrLessBrk}
 			\If{$A[i] \geq m$}
					\State	$g \gets g+1$			
			\Else
					\State $l \gets l+1$
			\EndIf			
		 	\If{$g \geq \lceil n \rdiv 2\rceil$}
					\State \Return \const{true}
	 		\ElsIf{$l > \lceil n \rdiv 2\rceil$}
					\State \Return \const{false}
			\EndIf		
	\EndFor
	\If{$g \geq l$}
			\State \Return \const{true}
	\Else
			\State \Return \const{false}
	\EndIf
\EndFunction		 	
\end{algorithmic}
\end{latin}
\end{algorithm}

 در هر دور از اجرای حلقه‌ی موجود در الگوریتم {\eqref{ch1:alg:btrMoreOrLess}} یکی از سه حالت زیر روی می‌دهد:
\شروع{فقرات}
\فقره مقدار متغیر {$g$} بزرگتر یا مساوی نصف تعداد کل خانه‌های آرایه‌ی {$A$} باشد. در این صورت می‌توان گفت حداقل نیمی از اعداد آرایه بزرگتر یا مساوی عدد {$m$} هستند و در نتیجه مقدار {$l$} در تکرارهای بعدی حلقه هرگز از {$g$} بیشتر نخواهد شد.
\فقره مقدار متغیر {$l$} بزرگتر از نصف تعداد کل خانه‌های آرایه‌ی {$A$} باشد. اگر این‌طور باشد یعنی بیش از نیمی از اعداد آرایه کمتر از عدد {$m$} هستند و این یعنی با ادامه‌ی اجرای الگوریتم مقدار {$g$} نمی‌تواند بیشتر از {$l$} شود.
\فقره هیچ یک از دو حالت قبلی برقرار نباشند و اجرای حلقه ادامه یابد.
\پایان{فقرات}
به این ترتیب با تغییرات اعمال ‌شده توانستیم بین بهترین و بدترین حالت اجرای الگوریتم تفاوت قائل ‌شویم و به محض تشخیص جواب به اجرای الگوریتم پایان دهیم.

\سوال الگوریتم {\eqref{ch1:alg:lnrSearch}} نشان دهنده‌ی شبه کد الگوریتم جستجوی ترتیبی\پانویس{{\lr{Sequential search}}} است. اگر عنصر با مقدار {$k$} در آرایه‌ی {$A$} پیدا شود آنگاه اندیس آن خانه برگشت داده شده و اجرای الگوریتم خاتمه می‌یابد. در غیر این صورت مقدار {$-1$} به نشانه‌ی عدم وجود عنصر مورد نظر در آرایه بازگردانده می‌شود. تعداد مقایسات انجام ‌شده در بدترین حالت و حالت متوسط این الگوریتم را به دست آورید (فرض کنید مقادیر آرایه‌ی {$A$} غیر تکراری هستند).

\begin{algorithm}
\caption{جستجوی ترتیبی}\label{ch1:alg:lnrSearch}
\begin{latin}
\begin{algorithmic}[1]
\Function{SequentialSearch}{$A,k$}		
		\State $n \gets \attrib{A}{length}$
		\For{$i \gets 1 \To n$}
				\If{$A[i] \isequal k$}
						\State \Return $i$
				\EndIf
		\EndFor
		\State \Return	$-1$		
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\پاسخ

\متن‌سیاه{تحلیل بدترین حالت}

در الگوریتم جستجوی ترتیبی می‌توان دو حالت زیر را به عنوان بدترین حالت در نظر گرفت:
\شروع{فقرات}
\فقره مقدار مورد جستجو در آخرین خانه‌ی آرایه‌ی {$A$} باشد.
\فقره مقدار مورد جستجو در آرایه‌ی {$A$} وجود نداشته باشد.
\پایان{فقرات}
برای هر یک از این دو حالت به بررسی تعداد مقایسات انجام ‌شده می‌پردازیم.

طبق فرض سوال هنگامی که مقدار مورد جستجو در آخرین خانه از آرایه قرار داشته باشد بدین معنی است که هیچ ‌کدام از عناصر موجود در خانه‌های ۱ تا {$n-1$} با مقدار مورد جستجو برابر نیستند. بنابراین الگوریتم در این حالت مقدار مورد جستجو را با تمام عناصر آرایه‌ی {$A$} مقایسه می‌کند تا مقدار مورد نظر را در خانه‌ی با اندیس {$n$} پیدا کند. پس در چنین حالتی {$n$} مقایسه انجام می‌شود.

در حالت دوم مقدار مورد جستجو با تمام عناصر آرایه مقایسه شده و به این نتیجه می‌رسیم که مقدار مورد نظر در آرایه وجود ندارد. پس در این حالت نیز به {$n$} مقایسه نیاز داریم.

به این ترتیب می‌توان گفت الگوریتم جستجوی ترتیبی در بدترین حالت دارای مرتبه‌ی زمانی {$O(n)$} است.

\متن‌سیاه{تحلیل حالت متوسط}

به طور کلی در الگوریتم‌های جستجو باید دو حالت مختلف را در تحلیل حالت متوسط در نظر بگیریم:
\شروع{فقرات}
\فقره مقدار مورد جستجو حتماً در آرایه‌ی {$A$} وجود دارد.
\فقره ممکن است مقدار مورد جستجو در آرایه‌ی {$A$} وجود نداشته باشد.
\پایان{فقرات} 

اگر مقدار مورد جستجو در آرایه موجود باشد آنگاه این مقدار می‌تواند در هر یک از {$n$} خانه‌ی آرایه قرار داشته باشد. با این فرض که احتمال وجود مقدار مورد جستجو در هر یک از {$n$} خانه‌ی آرایه مساوی یکدیگر و برابر با {$1/n$} باشد باید به این سوال پاسخ دهیم که اگر مقدار مورد جستجو در خانه‌ی اول باشد به چند مقایسه نیاز داریم؟ اگر در خانه‌ی دوم باشد به چند مقایسه نیاز داریم؟ و به همین ترتیب تا خانه‌ی {$n$}ام.

اگر مقدار مورد جستجو در خانه‌ی اول باشد به یک مقایسه، اگر در خانه‌ی دوم باشد به دو مقایسه و به همین ترتیب اگر در خانه {$n$}ام باشد به {$n$} مقایسه نیاز است. به این ترتیب متوسط تعداد مقایسات به صورتی که در ادامه آمده است به دست می‌آید:
\begin{displaymath}
A(n)=\sum_{i=1}^n{\frac{1}{n}\cdot i}=\frac{1}{n} \sum_{i=1}^n{ i}=\frac{1}{n}\cdot \frac{n(n+1)}{2}=\frac{n+1}{2}
\end{displaymath}
حال به بررسی حالتی می‌پردازیم که ممکن است مقدار مورد جستجو در آرایه وجود نداشته باشد. در چنین حالتی دارای {$n+1$} احتمال مختلف هستیم. {$n$} حالت برای هنگامی که مقدار مورد جستجو یافت شود و یک حالت برای هنگامی که چنین مقداری در آرایه وجود نداشته باشد. طبق مطالب گفته شده در تحلیل بدترین حالت، اگر مقدار مورد جستجو در آرایه نباشد آنگاه به {$n$} مقایسه نیاز داریم. اگر تمام احتمالات ممکن را برابر با هم و مساوی با {$1/(n+1)$} در نظر بگیریم آنگاه متوسط تعداد مقایسات به صورت زیر است:
\begin{align}
A(n) &= \biggl( \frac{1}{n+1} \sum_{i=1}^{n}{i} \biggr) + \biggl(\frac{1}{n+1}\cdot n \biggr) \nonumber\\
&=  \left( \frac{1}{n+1}\cdot  \frac{n(n+1)}{2} \right) + \frac{n}{n+1} \nonumber\\
&= \frac{n}{2} + \frac{n}{n+1} \nonumber\\
&= \frac{n}{2} + 1 - \frac{1}{n+1}\label{ch1:eqn:lnrSearchAvgCase}
\end{align}
از آنجا که اگر {$n$} به بی‌نهایت میل کند عبارت {$1/(n+1)$} در {\eqref{ch1:eqn:lnrSearchAvgCase}} به صفر میل می‌کند در نتیجه می‌توان رابطه‌ی {\eqref{ch1:eqn:lnrSearchAvgCase}} را به صورتی که در ادامه آمده است در نظر گرفت:
\begin{displaymath}
A(n)\approx\frac{n}{2}+1=\frac{n+2}{2}=\frac{n+1}{2}+\frac{1}{2}
\end{displaymath}
همان‌طور که مشخص است متوسط تعداد مقایسات در حالتی که ممکن است مقدار مورد جستجو در آرایه موجود نباشد تنها به اندازه‌ی {$1/2$} بیشتر از متوسط تعداد مقایسات در حالتی است که از وجود مقدار مورد جستجو در آرایه مطمئن هستیم. هنگامی که مقدار {$n$} بسیار بزرگ باشد می‌توان از مقدار {$1/2$} چشم‌پوشی کرد و این طور نتیجه گرفت که متوسط تعداد مقایسات در جستجوی ترتیبی، چه مقدار مورد جستجو در آرایه باشد و چه نباشد، برابر با {$(n+1)/2$} است. به عنوان نتیجه‌گیری باید گفت الگوریتم جستجوی ترتیبی در حالت متوسط از مرتبه‌ی {$O(n)$} است.

\سوال آرایه‌ی {$A[1\twodots n]$} که حاوی اعداد متمایز است را در نظر بگیرید. می‌خواهیم با استفاده از الگوریتم جستجوی ترتیبی به دنبال مقداری خاص در آرایه‌ی {$A$} بگردیم. فرض کنید به احتمال {$25$} درصد مقدار مورد جستجو در آرایه‌ی {$A$} وجود نداشته باشد. همچنین فرض کنید اگر مقدار مورد جستجو در آرایه‌ی {$A$} وجود داشته باشد آنگاه به احتمال {$75$} درصد در نیمه‌ی ابتدایی آرایه قرار دارد. با در نظر گرفتن مفروضات بیان شده، متوسط تعداد مقایسات انجام ‌شده توسط الگوریتم جستجوی ترتیبی چقدر است؟

\پاسخ

رابطه‌ی {\eqref{ch1:eqn:lnrSearchCmpSum}} نشان دهنده‌ی فرمول متوسط تعداد مقایسات در جستجوی ترتیبی است. این رابطه بیانگر این است که به احتمال {$p_i$}، نیاز به {$C_i$} مقایسه برای یافتن مقدار مورد جستجو داریم.
\begin{equation}
A(n) = \sum_{i=1}^{n}{p_i . C_i}\label{ch1:eqn:lnrSearchCmpSum}
\end{equation}
با توجه به فرضیات بیان شده در صورت سوال و رابطه‌ی {\eqref{ch1:eqn:lnrSearchCmpSum}} متوسط تعداد مقایسات برابر است با:
\begin{displaymath}
A(n) = \underbrace{\left( 0.25\cdot n\right)}_{\text{بخش اول}} +
\underbrace{0.75\cdot\left(\biggl( 0.75\sum_{i=1}^{n/2}{\frac{1}{n/2} \cdot i} \biggr) + \biggl( 0.25\sum_{i=(n/2)+1}^{n}{\frac{1}{n/2}\cdot i} \biggr) \right) }_{\text{بخش دوم}}
\end{displaymath}
بخش اول رابطه‌ی فوق مربوط به حالتی است که به احتمال {$25$} درصد مقدار مورد جستجو در آرایه وجود ندارد. در چنین حالتی نیاز به {$n$} مقایسه خواهد بود. بخش دوم این رابطه مربوط به حالتی است که به احتمال {$75$} درصد مقدار مورد جستجو در آرایه وجود دارد. در این حالت با توجه به مفروضات سوال باید دو حالت مختلف را در نظر بگیریم. حالت اول هنگامی است که مقدار مورد جستجو در نیمه‌ی اول آرایه است و حالت دوم هنگامی است که این مقدار در نیمه‌ی دوم آرایه است.

با ساده‌سازی {$A(n)$} به رابطه‌ی {$A(n)=(17n+12)/32$} می‌رسیم که این مقدار به طور تقریبی برابر با {$n/2$} است.

\سوال از الگوریتم جستجوی ترتیبی برای جستجو در یک آرایه‌ی مرتب نیز می‌توان استفاده کرد. الگوریتمی بنویسید که با در اختیار داشتن آرایه‌ای مانند {$A$}  که اعداد آن به صورت صعودی مرتب هستند، به جستجوی عنصری با مقدار {$k$} بپردازد. الگوریتم شما باید نسبت به الگوریتم جستجوی ترتیبی در یک آرایه نامرتب، تعداد مقایسات کمتری انجام دهد زیرا به محض اینکه مقدار مورد جستجو از عنصر نورد بررسی در آرایه کوچکتر باشد آنگاه عدم موفقیت برای یافتن مقدار مورد جستجو اعلام شده و اجرای الگوریتم خاتمه می‌یابد. مرتبه‌ی زمانی الگوریتم را در بدترین، بهترین و حالت متوسط به دست آورید.

\پاسخ

شبه کد الگوریتم جستجوی ترتیبی در یک آرایه‌ی مرتب در قالب الگوریتم {\eqref{ch1:alg:srtSeqSearch}} نشان داده شده است.

\begin{algorithm}
\caption{جستجوی ترتیبی در یک آرایه‌ی مرتب}\label{ch1:alg:srtSeqSearch}
\begin{latin}
\begin{algorithmic}[1]
\Function{SortedSequentialSearch}{$A,k$}		
		\State	$n \gets \attrib{A}{length}$
		\For{$i \gets 1 \To n$}
				\If{$A[i] \isequal k$}
						\State	\Return $i$
				\ElsIf{$A[i] > k$}
						\State	\Return $-1$
				\EndIf
		\EndFor
		\State	\Return	$-1$		
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\متن‌سیاه{تحلیل بهترین حالت}

بهترین حالت زمانی رخ می‌دهد که مقدار مورد جستجو در خانه‌ی اول آرایه و یا کوچکتر از آن باشد که در این صورت با یک بار اجرا شدن حلقه‌ از آن خارج شده و اجرای الگوریتم خاتمه می‌یابد. پس تعداد تکرار حلقه در بهترین حالت برابر با یک است و در نتیجه مرتبه‌ی زمانی بهترین حالت اجرای الگوریتم {$O(1)$} است.

\متن‌سیاه{تحلیل بدترین حالت}

بیشترین تعداد تکرار حلقه در یکی از حالات زیر رخ می‌دهد:
\شروع{فقرات}
\فقره مقدار مورد جستجو در آخرین خانه‌ی آرایه قرار داشته باشد.
\فقره مقدار مورد جستجو از مقدار آخرین خانه‌ی آرایه بزرگتر باشد.
\فقره مقدار مورد جستجو بزرگتر از عنصر ماقبل آخر و کوچکتر از عنصر آخر آرایه باشد.
\پایان{فقرات}
در هر یک از حالات بیان شده تعداد تکرار حلقه برابر با {$n$} است و این یعنی در بدترین حالت دارای مرتبه‌ی زمانی {$O(n)$} هستیم.

\متن‌سیاه{تحلیل حالت متوسط}

برای تحلیل حالت متوسط باید دو حالت مختلف را در نظر بگیریم:
\شروع{فقرات}
\فقره مقدار مورد جستجو حتماً در آرایه وجود دارد.
\فقره ممکن است مقدار مورد جستجو در آرایه وجود نداشته باشد.
\پایان{فقرات} 

اگر فرض کنیم مقدار مورد جستجو در آرایه‌ وجود دارد آنگاه {$n$} احتمال مختلف برای محل قرارگیری مقدار مورد جستجو قابل تصور است. حالت اول هنگامی است که مقدار مورد جستجو در خانه‌ی اول آرایه باشد. حالت دوم هنگامی است که مقدار مورد جستجو در خانه‌ی دوم آرایه باشد و به همین ترتیب تا حالت {$n$}ام که مقدار مورد جستجو در خانه {$n$}ام آرایه باشد. می‌دانیم اگر مقدار مورد نظر در خانه {$i$}ام آرایه باشد برای یافتن آن به {$i$} مقایسه نیاز داریم. اگر احتمال وجود مقدار مورد جستجو در هر یک از خانه‌های ۱ تا {$n$} را یکسان و برابر با {$1/n$} در نظر بگیریم آنگاه متوسط تعداد مقایسات برابر است با:
\begin{displaymath}
A(n)=\sum_{i=1}^n{\frac{1}{n} \cdot i}=\frac{1}{n} \sum_{i=1}^n{ i}=\frac{1}{n} \cdot \frac{n(n+1)}{2}=\frac{n+1}{2}
\end{displaymath}

اگر این احتمال وجود داشته باشد که مقدار مورد جستجو در آرایه موجود نباشد، آنگاه دارای {$2n+1$} حالت مختلف خواهیم بود. حالت اول هنگامی ‌است که مقدار مورد جستجو کوچکتر از مقدار خانه‌ی اول آرایه باشد . حالت دوم هنگامی رخ می‌دهد که مقدار مورد جستجو در خانه‌ی اول آرایه قرار داشته باشد. حالت سوم زمانی اتفاق می‌افتد که مقدار مورد جستجو دارای مقداری بزرگتر از خانه‌ی اول آرایه و کوچکتر از خانه‌ی دوم آرایه باشد. حالت چهارم زمانی روی می‌دهد که مقدار مورد نظر در خانه‌ی دوم آرایه قرار داشته باشد. به همین ترتیب تا حالت {$2n+1$} ام که زمانی روی می‌دهد که مقدار مورد جستجو از مقدار آخرین خانه‌ی آرایه بزرگتر باشد. در ادامه به تعیین تعداد مقایسات انجام ‌شده در هر از این حالات می‌پردازیم.

در حالتی که مقدار مورد جستجو کوچکتر از مقدار خانه‌ی اول آرایه باشد و همچنین حالتی که مقدار مورد جستجو در خانه‌ی اول آرایه قرار دارد تنها یک مقایسه لازم است. در حالتی که مقدار مورد جستجو در خانه‌ی دوم آرایه باشد و همچنین حالتی که مقدار مورد جستجو عددی بین اولین عنصر و دومین عنصر آرایه باشد دو مقایسه لازم است و به همین ترتیب ادامه می‌دهیم تا در نهایت در هر سه حالت زیر به {$n$} مقایسه نیاز خواهد بود:
\شروع{فقرات}
\فقره مقدار مورد جستجو در آخرین خانه‌ی آرایه باشد.
\فقره مقدار مورد جستجو بزرگتر از خانه‌ی ماقبل آخر و کوچکتر از خانه‌ی آخر آرایه باشد.
\فقره مقدار مورد جستجو بزرگتر از آخرین خانه‌ی آرایه باشد.
\پایان{فقرات}
با توجه به توضیحات ارائه شده متوسط تعداد مقایسات برابر است با:
\begin{align*}
A(n)&=\left( \sum_{i=1}^{n-1}{\frac{2}{2n+1} \cdot i} \right) + \left( \frac{3}{2n+1} \cdot n\right)\\
	&=\left({\frac{2}{2n+1}\cdot\frac{n(n-1)}{2}}\right)+\frac{3n}{2n+1}\\
	&=\frac{n^2+2n}{2n+1}\\
	&=\frac{n+1}{2}+\frac{n-1}{2n+1}
\end{align*}
اگر مقدار {$n$} به بی‌نهایت میل کند می‌توان {$A(n)$} را به صورت زیر تقریب زد:
\begin{displaymath}
A(n)\approx\frac{n+1}{2} + \frac{1}{2}\approx\frac{n+1}{2}
\end{displaymath}
به این ترتیب می‌توان گفت الگوریتم جستجوی ترتیبی در یک آرایه مرتب، چه مقدار مورد جستجو در آرایه موجود باشد و چه نباشد، از مرتبه‌ی {$O(n)$} است.

\سوال جستجوی یک مقدار در یک آرایه‌ی مرتب صعودی به روشی که در ادامه آمده است را در نظر بگیرید. 

مقدار مورد جستجو با مقدار خانه‌ی میانی آرایه مقایسه می‌شود. سه حالت ممکن بعد از عمل مقایسه عبارت‌اند از:
\شروع{شمارش}
\فقره مقدار مورد جستجو با مقدار خانه‌ی میانی آرایه برابر است که در این صورت عمل جستجو با موفقیت خاتمه می‌یابد.
\فقره مقدار مورد جستجو از مقدار خانه‌ی میانی آرایه کوچکتر است که در این صورت باید به جستجوی مقدار مورد نظر در خانه‌های قبل از خانه‌ی میانی، یعنی نیمه‌ی اول آرایه، بپردازیم.
\فقره مقدار مورد جستجو از مقدار خانه‌ی میانی آرایه بزرگتر است که در این صورت باید به دنبال مقدار مورد نظر در خانه‌های بعد از خانه‌ی میانی، یعنی نیمه‌ی دوم آرایه، باشیم. 
\پایان{شمارش}
حالات ۲ و ۳ منجر به نادیده گرفتن بخشی از آرایه در ادامه‌ی روند اجرای الگوریتم می‌شوند. این روند به همین ترتیب ادامه یافته و در هر مرحله نیمی از عناصر بخش باقی مانده از آرایه نادیده گرفته می‌شوند تا اینکه یا مقدار مورد جستجو پیدا شود و یا به این نتیجه برسیم که این مقدار در آرایه وجود ندارد. به این روش جستجو، جستجوی دودویی\پانویس{{\lr{Binary search}}} گفته می‌شود. شبه کد الگوریتم جستجوی دودویی در الگوریتم {\eqref{ch1:alg:binSearch}} نشان داده شده است. مرتبه‌ی زمانی الگوریتم جستجوی دودویی را در بهترین، بدترین و حالت متوسط به دست آورید (احتمال وجود مقدار مورد جستجو در هر یک از خانه‌های آرایه و همچنین احتمال اینکه مقدار مورد جستجو در آرایه موجود نباشد برابر هستند).

\begin{algorithm}
\caption{جستجوی دودویی}\label{ch1:alg:binSearch}
\begin{latin}
\begin{algorithmic}[1]
\Function{BinarySearch}{$A,k$}
		\State	$n \gets \attrib{A}{length}$
		\State	$\id{begin} \gets 1$
		\State	$\id{end} \gets n$
		\While{$\id{start} \leq \id{end}$}
				\State	$ \id{middle} \gets (\id{start}+\id{end}) \div 2 $
				\If{$k \isequal A[\id{middle}]$}
						\State	\Return $\id{middle}$
				\ElsIf{$k < A[\id{middle}]$	}
						\State	$\id{middle} \gets \id{end} - 1$
				\Else	
					 	\State	$\id{middle} \gets \id{begin} + 1$	
				\EndIf
		\EndWhile
		\State	\Return	$-1$
\EndFunction
\end{algorithmic}
\end{latin}
\end{algorithm}

\پاسخ

برای سادگی تحلیل، فرض می‌کنیم تعداد عناصر آرایه برابر با {$n=2^{k}-1$} ({$k\geqslant 1$}) است. در حالت کلی می‌توان گفت اگر در ابتدای یک دور از اجرای حلقه دارای {$2^{k}-1$} عنصر در محدوده‌ی {\id{begin}} تا {\id{end}} باشیم آنگاه {$2^{k-1}-1$} عنصر در نیمه‌ی سمت چپ، یک عنصر به عنوان عنصر میانی و {$2^{k-1}-1$} عنصر در نیمه‌ی سمت راست آرایه قرار خواهند داشت. در نتیجه در ابتدای دور بعدی اجرای حلقه تعداد عناصر موجود در محدوده‌ی {\id{begin}} تا {\id{end}} به {$2^{k-1}-1$} عنصر کاهش می‌یابد زیرا روند اجرای الگوریتم یا در نیمه‌ی سمت چپ و یا در نیمه‌ی سمت راست آرایه ادامه خواهد یافت.

\متن‌سیاه{تحلیل بدترین حالت}

با توجه به توضیحات بیان شده، در هر مرحله از اجرای حلقه یک واحد از توان عدد ۲ کم می‌شود. همچنین می‌دانیم که آخرین دور از اجرای حلقه زمانی روی می‌دهد که تعداد عناصر موجود در محدوده {\id{begin}} تا {\id{end}} به یک عنصر برسد و این زمانی اتفاق می‌افتد که مقدار {$k$} یک باشد (مقدار عبارت {$2^{k}-1$} زمانی برابر با یک خواهد شد که مقدار {$k$} برابر با یک باشد). به این ترتیب می‌توان گفت در بدترین حالت از اجرای الگوریتم، با فرض اینکه تعداد عناصر آرایه برابر با {$2^{k}-1$} است، تعداد دفعات اجرای حلقه برابر با {$k$} است و این یعنی مرتبه‌ی زمانی الگوریتم جستجوی دودویی از مرتبه‌ی {$O(k)$} است. با در نظر گرفتن رابطه‌ی {$n=2^k-1$} و به دست آوردن {$k$} بر حسب {$n$} می‌توان نتیجه گرفت {$k=\lg (n+1)$} و در نتیجه مرتبه‌ی زمانی الگوریتم جستجوی دودویی در بدترین حالت از مرتبه‌ی {$O(\lg n)$} است.

\متن‌سیاه{تحلیل بهترین حالت}

بهترین حالت زمانی روی می‌دهد که در اولین دور از اجرای حلقه مقدار مورد جستجو با مقدار خانه‌ی میانی آرایه برابر باشد که در این صورت با انجام یک مقایسه مقدار مورد جستجو پیدا می‌شود. پس الگوریتم جستجوی دودویی در بهترین حالت از مرتبه‌ی {$O(1)$} است.

\متن‌سیاه{تحلیل حالت متوسط}

به منظور درک بهتر تحلیل حالت متوسط بهتر است روند اجرای الگوریتم جستجوی دودویی را با استفاده از یک درخت تصمیم دودویی\پانویس{{\lr{Binary decision tree}}} مدل‌ کنیم. گره‌های چنین درختی با اندیس هر خانه‌ای از آرایه که در هر دور از اجرای حلقه با مقدار مورد جستجو مقایسه می‌شود برچسب‌گذاری می‌شود. عناصری که در صورت کوچکتر بودن مقدار مورد جستجو از مقدار میانی، در دورهای بعدی با مقدار مورد جستجو مقایسه می‌شوند در زیر درخت چپ قرار می‌گیرند. عناصری که در صورت بزرگتر بودن مقدار مورد جستجو از مقدار میانی، در دورهای بعدی با مقدار مورد جستجو مقایسه می‌شوند در زیر درخت راست قرار می‌گیرند. اگر فرض کنیم دارای آرایه‌ای با هفت عنصر هستیم و اندیس اولین خانه‌ی آرایه از عدد یک شروع شود آنگاه درخت تصمیم دودویی برای چنین آرایه‌ای مانند شکل {\eqref{ch1:fig:binDecTree}} خواهد بود.

شکل {\eqref{ch1:fig:binDecTree}} نشان می‌دهد که در دور اول از اجرای حلقه، عنصر میانی در خانه‌ی چهار آرایه قرار دارد. با مقایسه‌ی مقدار مورد جستجو با مقدار موجود در خانه‌ی چهارم، با فرض اینکه مقدار مورد جستجو در خانه‌ی چهارم آرایه نباشد، یا به نیمه‌ی سمت چپ آرایه (خانه‌های ۱ تا ۳) و یا به نیمه‌ی سمت راست آرایه (خانه‌های ۴ تا ۷) می‌رویم. اگر به نیمه‌ی سمت چپ آرایه برویم آنگاه در دور بعدی از اجرای حلقه، عنصر میانی در خانه‌ با اندیس دو قرار دارد و اگر به نیمه‌ی سمت راست آرایه برویم آنگاه عنصر میانی در خانه با اندیس شش قرار دارد و به همین ترتیب.
\begin{figure}
\begin{center}
\scalebox{0.45}
{
\begin{pspicture}(0,-3.86)(16.44,3.86)
\pscircle[linewidth=0.07,dimen=outer](12.98,0.3){1.0}
\pscircle[linewidth=0.07,dimen=outer](8.2,2.9){0.98}
\pscircle[linewidth=0.07,dimen=outer](3.42,0.3){1.0}
\pscircle[linewidth=0.07,dimen=outer](1.0,-2.88){1.0}
\psline[linewidth=0.04cm](7.48,2.32)(3.4,1.28)
\psline[linewidth=0.04cm](8.94,2.32)(13.02,1.28)
\psline[linewidth=0.04cm](2.84,-0.46)(1.0,-1.9)
\psline[linewidth=0.04cm](4.0,-0.5)(5.8,-1.9)
\psline[linewidth=0.04cm](12.38,-0.48)(10.6,-1.9)
\psline[linewidth=0.04cm](13.54,-0.46)(15.4,-1.92)
\pscircle[linewidth=0.07,dimen=outer](15.42,-2.88){0.98}
\usefont{T1}{ptm}{m}{it}
\rput(8.2265625,2.955){\LARGE $4$}
\rput(3.4417188,0.335){\LARGE $2$}
\rput(13.019688,0.335){\LARGE $6$}
\rput(1.0384375,-2.845){\LARGE $1$}
\rput(5.8125,-2.845){\LARGE $3$}
\rput(10.6175,-2.845){\LARGE $5$}
\rput(15.410156,-2.845){\LARGE $7$}
\pscircle[linewidth=0.07,dimen=outer](5.8,-2.88){1.0}
\pscircle[linewidth=0.07,dimen=outer](10.62,-2.88){1.0}
\end{pspicture} 
}\caption{درخت تصمیم دودویی برای آرایه‌ای با هفت عنصر}\label{ch1:fig:binDecTree}
\end{center}
\end{figure}

در حالت کلی می‌دانیم که چنین درختی تقریباً متوازن است زیرا در هر مرحله از اجرای الگوریتم، آرایه از نقطه‌ی میانی به دو قسمت تقسیم می‌شود. با توجه به فرمول‌های موجود برای درختان دودویی می‌توان گفت درخت تصمیم یک آرایه‌‌ی {$n$} عنصری دارای حداکثر {$\lfloor\lg n \rfloor + 1$} سطح است (با این فرض که شماره‌ی سطوح از یک شروع شود). تعداد سطوح برابر است با حداکثر تعداد مقایسات برای یافتن یک مقدار در یک آرایه‌ی {$n$} عنصری با استفاده از الگوریتم جستجوی دودویی. با توجه به اینکه مقدار {$n$} را به صورت {$n=2^{k}-1$} فرض کردیم پس درخت تصمیم آرایه‌ای با {$2^{k}-1$} عنصر یک درخت دودویی با حداکثر تعداد گره خواهد بود. با به دست آوردن {$k$}  برحسب {$n$}  می‌توان به این نتیجه رسید که درخت تصمیم دارای {$k$} سطح است و {$k$} برابر است با {$k=\lg (n+1)$}. 

در ادامه با استفاده از ایده‌ی درخت‌ تصمیم دودویی به تحلیل دو حالت زیر در تحلیل حالت متوسط می‌پردازیم:
\شروع{فقرات}
\فقره مقدار مورد جستجو در آرایه وجود دارد.
\فقره ممکن است مقدار مورد جستجو در آرایه وجود نداشته باشد.
\پایان{فقرات} 

اگر فرض کنیم مقدار مورد جستجو در آرایه وجود دارد آنگاه مقدار مورد جستجو می‌تواند با احتمال مساوی در هر یک از {$n$} خانه‌ی آرایه قرار داشته باشد (این احتمال برای هر خانه برابر با {$1/n$} است). اگر درخت تصمیم فرآیند جستجو را در نظر بگیریم آنگاه می‌توان دید که اگر مقدار مورد جستجو در ریشه‌ی درخت باشد آنگاه تنها به یک مقایسه برایب یافتن آن نیاز است. اگر مقدار مورد جستجو در هر یک از دو خانه‌ی واقع در سطح دوم درخت باشد به دو مقایسه نیاز است و به همین ترتیب. در حالت کلی می‌توان گفت اگر مقدار مورد جستجو در خانه‌ای در سطح {$k$}ام باشد آنگاه نیاز به {$k$} مقایسه برای یافتن آن داریم. می‌دانیم که در یک درخت دودویی تعداد گره‌ها در سطح {$i$} برابر با {$2^{i-1}$} است و تعداد سطوح در حالتی که دارای {$2^{k}-1$} گره هستیم برابر با {$k$}  است. حال با توجه به اینکه تعداد سطوح، تعداد گره در هر سطح و همچنین تعداد مقایسه برای هر سطح را در اختیار داریم می‌توان متوسط تعداد مقایسات را از رابطه‌ی زیر به دست آورد:
\begin{align}
A(n) &= \frac{1}{n} \sum_{i=1}^{k}{i \cdot 2^{i-1}}\nonumber\\
&= \frac{1}{2n}\sum_{i=1}^{k}{i \cdot 2^{i}}\label{ch1:eqn:binSrchAvgCase}
\end{align}
با توجه به اینکه حاصل عبارت {$\sum_{i=1}^{k}{i \cdot 2^{i}}$} برابر با {$(k-1)2^{k+1} + 2$} است می‌توان رابطه‌ی {\eqref{ch1:eqn:binSrchAvgCase}} را به صورت نشان داده شده در رابطه‌ی {\eqref{ch1:eqn:smpBinSrchAvgCase1}} نوشت.
\begin{equation}
A(n)=\frac{1}{2n}\biggl( (k-1)2^{k+1} + 2 \biggr)\label{ch1:eqn:smpBinSrchAvgCase1}
\end{equation}
با ساده‌سازی {\eqref{ch1:eqn:smpBinSrchAvgCase1}} داریم:
\begin{align}
A(n) &= \frac{1}{2n}\biggl( (k-1)2^{k+1} + 2 \biggr) \nonumber\\
&= \frac{1}{n}\biggl( (k-1)2^{k} + 1 \biggr) \nonumber\\
&= \frac{1}{n}\biggl( k2^{k} -2^{k}  + 1 \biggr) \nonumber\\
&= \frac{k2^{k} - (2^{k}-1)}{n}\label{ch1:eqn:smpBinSrchAvgCmp2}
\end{align}
اگر در {\eqref{ch1:eqn:smpBinSrchAvgCmp2}} به جای {$2^{k}-1$} معادل آن یعنی {$n$} را قرار دهیم به رابطه‌ی {\eqref{ch1:eqn:BinSrchAvgSub1}} می‌رسیم.
\begin{equation}
A(n)=\frac{k2^{k}}{n} - 1\label{ch1:eqn:BinSrchAvgSub1}
\end{equation}
با توجه به اینکه فرض کردیم {$n=2^{k}-1$} پس {$2^k=n+1$}. با جایگذاری {$n+1$} به جای {$2^k$} در {\eqref{ch1:eqn:BinSrchAvgSub1}} خواهیم داشت:

\begin{align}
A(n) &= \frac{k(n+1)}{n} - 1\nonumber\\
&=\frac{kn+k}{n} - 1\nonumber\\
&= k+ \frac{k}{n} - 1\label{ch1:eqn:BinSrchAvgSub2}
\end{align}
هنگامی که {$n$} به بی‌نهایت میل کند {$k/n$} به صفر میل می‌کند. با در نظر گرفتن این موضوع می‌توان  {\eqref{ch1:eqn:BinSrchAvgSub2}} را به صورت زیر در تقریب زد:
\begin{displaymath}
A(n) \approx k-1 = \lg (n+1) - 1
\end{displaymath}
به این ترتیب می‌توان گفت متوسط تعداد مقایسات در حالتی که مقدار مورد جستجو در آرایه وجود دارد برابر با {$\lg (n+1) - 1$} است.

اگر حالتی را در نظر بگیریم که ممکن است مقدار مورد جستجو در آرایه وجود نداشته باشد آنگاه اگر مقدار مورد جستجو در آرایه وجود داشته باشد  دارای {$n$} مکان احتمالی برای قرارگیری آن هستیم. همچنین دارای {$n+1$} احتمال دیگر برای حالتی هستیم که مقدار مورد جستجو در آرایه وجود ندارد. احتمال اول از این {$n+1$} احتمال مختلف هنگامی است که مقدار مورد جستجو از عنصر اول آرایه کوچکتر باشد. احتمال دوم زمانی رخ می‌دهد که مقدار مورد جستجو از عنصر اول آرایه بزرگتر و از عنصر دوم کوچکتر باشد و به همین ترتیب تا احتمال {$n+1$} ام که زمانی اتفاق می‌افتد که مقدار مورد جستجو از عنصر {$n$}ام آرایه بزرگتر باشد. در هر یک از این {$n+1$} حالت به {$k$} مقایسه نیاز داریم تا به عدم وجود مقدار مورد جستجو در آرایه پی ‌ببریم. بدین ترتیب دارای {$2n+1$} احتمال مختلف هستیم که باید در محاسبات خود لحاظ کنیم. با توجه به توضیحات داده شده برای متوسط تعداد مقایسات داریم:
\begin{equation}
A(n)= \frac{1}{2n+1}\left( \left( \sum_{i=1}^{k}{i \cdot 2^{i-1}} \right) + (n+1)k  \right)\label{ch1:eqn:binSearch6}
\end{equation}
اگر در {\eqref{ch1:eqn:binSearch6}} به جای عبارت {$\sum_{i=1}^{k}{i \cdot 2^{i-1}}$} معادل آن یعنی {$ (k-1)2^{k} + 1$} را قرار دهیم به رابطه‌ی {\eqref{ch1:eqn:binSearch7}} می‌رسیم.
\begin{equation}
A(n) = \frac{ \Bigl( (k-1)2^{k} + 1 \Bigr) + (n+1)k}{2n+1}\label{ch1:eqn:binSearch7}
\end{equation}

با ساده‌سازی {\eqref{ch1:eqn:binSearch7}} داریم:
\begin{align*}
A(n) &= \frac{ \Bigl( (k-1)2^{k} + 1 \Bigr) + \Bigl( 2^k -1+1 \Bigr) k}{2(2^k -1)+1} \\
&= \frac{ \Bigl( k2^{k}-2^{k} + 1 \Bigr) + k2^k}{2^{k+1}-1} \\
&= \frac{ k2^{k+1}-2^{k} + 1}{2^{k+1}-1} \\
&\approx \frac{ k2^{k+1}-2^{k}}{2^{k+1}} \\
&= k - \frac{1}{2} = \lg (n+1) - \frac{1}{2}
\end{align*}
پس متوسط تعداد مقایسات در حالتی که ممکن است مقدر مورد جستجو در آرایه وجود نداشته باشد برابر با {$\lg (n+1) - (1/2)$} است.

با توجه به اینکه متوسط تعداد مقایسات برای حالتی که مقدار مورد جستجو در آرایه وجود دارد برابر با {$\lg (n+1) - 1$} و برای حالتی که ممکن است مقدار مورد جستجو در آرایه وجود نداشته باشد برابر با {$\lg (n+1) - (1/2)$} است پس می‌توان گفت مرتبه‌ی زمانی الگوریتم جستجوی دودویی در حالت متوسط برابر با {$O(\lg n)$} است.

\سوال الگوریتم مرتب‌سازی یک آرایه‌ی {$n$} عنصری را در نظر بگیرید که در ابتدا کوچکترین عنصر آرایه را پیدا کرده و با عنصر ابتدایی آرایه، یعنی {$A[1]$}، جابجا می‌کند. سپس دومین کوچکترین عنصر را پیدا کرده و با دومین عنصر، یعنی {$A[2]$}، جابجا می‌کند و به همین ترتیب تا انتهای آرایه. این روش مرتب سازی، مرتب‌سازی انتخابی\پانویس{{\lr{Selection sort}}} نام دارد. شبه ‌کد الگوریتم مرتب‌سازی انتخابی را نوشته و سپس مرتبه‌ی زمانی بهترین و بدترین حالت اجرای آن را به دست آورید.

\پاسخ

شبه ‌کد الگوریتم مرتب‌سازی انتخابی در قالب الگوریتم {\eqref{ch1:alg:selectionSort}} آورده شده است. مرتبه‌ی زمانی این الگوریتم در بهترین و بدترین حالت یکسان است زیرا در هر دوی این حالات مجموع تعداد تکرار دو حلقه‌ی موجود در الگوریتم یکسان هستند. تحلیل مرتبه‌ی زمانی الگوریتم مرتب‌سازی انتخابی در ادامه آمده است.

\begin{algorithm}
\caption{مرتب‌سازی انتخابی}\label{ch1:alg:selectionSort}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{SelectionSort}{$A$}
		\State	$n \gets \attrib{A}{length}$
		\For{$i \gets 1 \To n-1$}
				\State	$\id{minIdx} \gets i $
				\For{$j \gets i+1 \To n$}
						\If{$A[j] < A[\id{minIdx}] $}
								\State	$\id{minIdx} \gets j$						
						\EndIf
				\EndFor
				\State	\bcall{Swap}{$A[i], A[\id{minIdx}]$}
		\EndFor
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

در هر دو حالت بهترین و بدترین، در دور اول از اجرای حلقه‌ی بیرونی، حلقه‌ی درونی {$n-1$} بار اجرا می‌شود و کوچکترین عنصر یافته شده در محدوده‌ی {$A[1\twodots n]$} با مقدار موجود در {$A[1]$} جابجا می‌شود. در دور دوم از اجرای حلقه‌ی بیرونی، حلقه‌ی درونی {$n-2$} بار اجرا شده و کوچکترین عنصر در محدوده‌ی {$A[2\twodots n]$} یافته شده  و با مقدار موجود در {$A[2]$} جابجا می‌شود. این روند به همین ترتیب ادامه می‌یابد تا دور آخر از اجرای حلقه‌ی بیرونی که در نتیجه‌ی آن حلقه‌ی درونی تنها یک بار اجرا می‌شود. بدین ترتیب مجموع تعداد تکرار دو حلقه‌ی موجود در الگوریتم مرتب‌سازی انتخابی به صورت زیر به دست می‌آید:
\begin{align*}
C(n) &= \sum_{i=1}^{n-1}{(n-i)}\\
&=\sum_{i=1}^{n-1}{n} - \sum_{i=1}^{n-1}{i}\\
&=n(n-1) - \frac{n(n-1)}{2}\\
&= \frac{n(n-1)}{2}\\
&= \frac{1}{2}n^2-\frac{1}{2}n
\end{align*}
به این ترتیب می‌توان گفت الگوریتم مرتب‌سازی انتخابی در بهترین و بدترین حالت از مرتبه‌ی {$\Theta (n^2)$} است.

\سوال شبه کد الگوریتم مرتب‌سازی درجی بازگشتی در قالب الگوریتم {\eqref{ch1:alg:recurInsSort}} آورده شده است. برای مرتب‌سازی آرایه‌ی  {$A[1\twodots n]$} این الگوریتم به صورت {\bcall{InsertionSort}{$A,n$}} فراخوانی می‌شود. این الگوریتم برای مرتب‌سازی صعودی عناصر آرایه‌ی {$A$} ابتدا به صورت بازگشتی زیرآرایه‌ی {$A[1\twodots n-1]$} را مرتب کرده و سپس مقدار موجود در خانه‌ی {$A[n]$} را طوری در آرایه درج می‌کند که {$A[1\twodots n]$} به صورت مرتب درآید. برای هر یک از حالات بهترین، متوسط و بدترین، رابطه‌ای بازگشتی بنویسید که نشان دهنده مرتبه‌ی زمانی الگوریتم در آن حالت باشد. با توجه به مرتب بودن زیرآرایه‌ی {$A[1\twodots n-1]$} استراتژی یافتن مکان مناسب برای درج عنصر {$A[n]$} را در صورت امکان بهبود دهید.

\begin{algorithm}
\caption{مرتب‌سازی درجی بازگشتی}\label{ch1:alg:recurInsSort}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{InsertionSort}{$A,n$}
		\If{$n \isequal 1$}
				\State	\Return
		\Else
				\State	\bcall{InsertionSort}{$A,n-1$}
				\State	$i \gets n-1$\label{ch1:alg:line:recInsSrtAftCall}
				\State	$x \gets A[n]$
				\While{$i>0 \And x < A[i]$}
						\State	$A[i+1] \gets A[i]$
						\State	$i \gets i-1$
				\EndWhile
				\State	$A[i+1] \gets x$	\label{ch1:alg:line:recInsSrtIns}
		\EndIf
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

\پاسخ

بهترین حالت در مرتب‌سازی درجی بازگشتی زمانی روی می‌دهد که مقادیر آرایه‌ از قبل به صورت صعودی مرتب باشند. در چنین حالتی شرط حلقه برقرار نبوده و در نتیجه زمان مصرفی خطوط {\ref{ch1:alg:line:recInsSrtAftCall}} تا {\ref{ch1:alg:line:recInsSrtIns}} از مرتبه‌ی {$O(1)$} خواهد بود. بدین ترتیب می‌توان رابطه‌ی بازگشتی بهترین حالت اجرای الگوریتم مرتب‌سازی درجی بازگشتی را به صورت زیر در نظر گرفت.
\begin{displaymath}
T(n) =
\begin{cases}
\Theta (1) & n=1\\
T(n-1)+\Theta (1) &  n>1
\end{cases}
\end{displaymath}
در حالت متوسط باید به این نکته توجه کرد که مقدار موجود در خانه‌ی {$A[n]$} می‌تواند در هر یک از مکان‌های ۱ تا {$n$}  از آرایه قرار بگیرد. اگر احتمال قرارگیری عنصر {$A[n]$} در هر یک از این {$n$} خانه را برابر با {$1/n$} در نظر بگیریم آنگاه متوسط تعداد تکرار حلقه برابر با {$(n+1)/2$} است و در نتیجه زمان مصرفی خطوط {\ref{ch1:alg:line:recInsSrtAftCall}} تا {\ref{ch1:alg:line:recInsSrtIns}} از مرتبه‌ی {$O(n)$} خواهد بود. با توجه به توضیحات بیان شده می‌توان رابطه‌‌ی بازگشتی حالت متوسط را به صورت زیر نوشت.
\begin{displaymath}
T(n) =
\begin{cases}
\Theta (1) & n=1\\
T(n-1)+\Theta (n) & n>1
\end{cases}
\end{displaymath}
بدترین حالت در مرتب‌سازی درجی بازگشتی زمانی روی می‌دهد که آرایه‌ از قبل به صورت نزولی مرتب باشد. در چنین حالتی در هر فراخوانی بازگشتی دارای بیشترین تعداد تکرار حلقه خواهیم بود و این تعداد برابر با {$n-1$} است. پس مرتبه‌ی زمانی اجرای خطوط {\ref{ch1:alg:line:recInsSrtAftCall}} تا {\ref{ch1:alg:line:recInsSrtIns}} برابر با {$O(n)$} است و در نتیجه رابطه‌ی بازگشتی بدترین حالت به صورت زیر است.
\begin{displaymath}
T(n) =
\begin{cases}
\Theta (1) & n=1\\
T(n-1)+\Theta (n) & n>1
\end{cases}
\end{displaymath}
با توجه به اینکه زیرآرایه‌ی {$A[1\twodots n-1]$} مرتب است می‌توان به جای جستجوی ترتیبی از جستجوی دودویی برای یافتن مکان مناسب برای درج مقدار موجود در خانه‌ی {$A[n]$} استفاده کرد. شبه کد الگوریتم تغییر یافته در قالب الگوریتم {\eqref{ch1:alg:recurBinInsSort}} نشان داده شده است.

\begin{algorithm}
\caption{مرتب‌سازی درجی دودویی بازگشتی}\label{ch1:alg:recurBinInsSort}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{‌BinInsertionSort}{$A,n$}
		\If{$ n \isequal 1 $}
				\State	\Return
		\Else
				\State	\bcall{BinInsertionSort}{$A,n-1$}
				\State	$\id{begin} \gets 1$		
				\State	$\id{end} \gets n-1$		
%				\algstore{‌binInsertionSortBrk}
%\end{algorithmic}
%\end{latin}
%\end{algorithm}
%
%\begin{algorithm}
%\caption*{مرتب‌سازی درجی دودویی بازگشتی - ادامه}
%\begin{latin}
%\begin{algorithmic}[1]
%				\algrestore{‌binInsertionSortBrk}
				\State	$x \gets A[n]$
				\While{$\id{begin} < \id{end}$}
						\State	$\id{middle} \gets (\id{begin} + \id{end}) \div 2$
						\If{$x < A[\id{middle}]$	}
								\State	$\id{end} \gets \id{middle}$						
						\Else
								\State	$\id{begin} \gets \id{middle} + 1$		
						\EndIf
				\EndWhile
				\For{$i=n$ \Downto $\id{begin}+1$}
						\State	$A[i] \gets A[i-1]$
				\EndFor
				\State	$A[\id{begin}] \gets x$				
		\EndIf
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

\سوال مرتبه‌ی زمانی قطعه کد زیر را تعیین کنید (در این قطعه کد {$\bmod$} به معنی عملگر باقیمانده است).

\begin{latin}
\begin{algorithmic}[1]
		\For{$i \gets 1 \To n$}
				\If{$(i \bmod 2) \neq 0$}
						\For{$j \gets 1 \To i$}
								\State	$x \gets x+1$
						\EndFor
						\For{$j \gets i \To n$}
								\State	$y \gets y+1$							
						\EndFor
				\EndIf
		\EndFor
\end{algorithmic}
\end{latin}

\پاسخ

برای سادگی کار ابتدا دو حلقه‌‌ی داخلی را تبدیل به یک حلقه می‌کنیم. این کار به این دلیل امکان‌پذیر است که به دنبال مرتبه‌ی زمانی هستیم و اینکه حلقه‌ها چه عملیاتی انجام می‌دهند، مادامی که در بدنه‌ی حلقه‌ها شمارنده‌ها تغییر داده نشوند، اهمیت ندارد. کد تغییر یافته در ادامه آمده است.

\begin{latin}
\begin{algorithmic}[1]
		\For{$i \gets 1 \To n$}
				\If{$(i \bmod 2) \neq 0$}
						\For{$j \gets 1 \To n+1$}
								\State	$x \gets x+1$
								\State	$y \gets y+1$		
						\EndFor
				\EndIf
		\EndFor
\end{algorithmic}
\end{latin}

توجه کنید که در قطعه کد بالا تعداد تکرار حلقه‌ی داخلی برابر با مجموع تعداد تکرار دو حلقه‌ی {\lr{for}} داخلی موجود در قطعه کد اولیه است. در نتیجه پیچیدگی زمانی قطعه کد جدید با قطعه کد اولیه تفاوتی ندارد.

با در نظر گرفتن قطعه کد جدید می‌توان گفت حلقه‌ی بیرونی {$n$} بار تکرار می‌شود در حالیکه حلقه‌ی درونی تنها زمانی اجرا می‌شود که {$n$} فرد باشد. با توجه به اینکه در بازه‌ی {$[1,n]$} تقریباً نیمی از اعداد فرد و نیمی زوج هستند می‌توان گفت در نیمی از تکرارها شرط {\lr{if}} بررسی شده و حلقه‌ی درونی اجرا نمی‌شود اما در نیمی دیگر از تکرارها به دلیل درستی شرط {\lr{if}} حلقه‌ی درونی نیز اجرا خواهد شد. با توجه به توضیحات داده شده می‌توان زمان مصرفی قطعه کد را به صورت زیر در نظر گرفت:
\begin{equation*}
\dfrac{n}{2}O(1) + \dfrac{n}{2}O(n) = O(n) + O(n^2) = O(n^2)
\end{equation*}
پس مرتبه‌ی زمانی قطعه کد مورد نظر از مرتبه‌ی {$O(n^2)$} است.

\سوال ایده‌ی مرتب‌سازی حبابی\پانویس{{\lr{Bubble sort}}} این است که به تدریج مقادیر بزرگتر در یک آرایه به سمت انتها و مقادیر کوچکتر به سمت ابتدای آرایه حرکت کنند. این الگوریتم برای مرتب‌سازی یک آرایه تعدادی گذر\پانویس{\lr{Pass}} را انجام می‌دهد. در هر گذر مقادیر خانه‌های مجاور با یکدیگر مقایسه می‌شوند. اگر ترتیب دو خانه‌ی مجاور درست نباشد، مقادیر آن دو با یکدیگر جابجا می‌شوند. در هر گذر از ابتدای آرایه شروع کرده و مقادیر خانه‌های اول و دوم با یکدیگر مقایسه می‌شوند و در صورت نیاز به جابجایی با یکدیگر جابجا می‌شوند، سپس مقادیر خانه‌های دوم و سوم با یکدیگر مقایسه می‌شوند و در صورت نیاز به جابجایی با یکدیگر جابجا می‌شوند و به همین ترتیب تا مقایسه‌ی خانه {$(n-1)$}ام با خانه‌ی {$n$}ام. به این ترتیب پس از پایان گذر اول بزرگترین مقدار در خانه‌ی {$n$}ام آرایه قرار می‌گیرد. در گذر دوم چون می‌دانیم بزرگترین مقدار در خانه‌ی {$n$}ام آرایه قرار دارد می‌توانیم مقدار واقع در این خانه را نادیده بگیریم. در نتیجه در گذر دوم، دومین بزرگترین مقدار پیدا شده و در دومین خانه از انتهای آرایه قرار می‌گیرد و به همین ترتیب تا پایان گذر {$(n-1)$}ام که آرایه کاملاً مرتب خواهد بود. در اجرای هر یک از این گذرها اگر حداقل یک جابجایی‌ انجام نشود می‌توان گفت تمام خانه‌های آرایه مرتب شده‌اند و نیازی به اجرای ادامه‌ی الگوریتم وجود ندارد. الگوریتم {\eqref{ch1:alg:bubbleSort}} شبه کد الگوریتم مرتب‌سازی حبابی را نشان می‌دهد.

\begin{algorithm}
\caption{مرتب‌سازی حبابی}\label{ch1:alg:bubbleSort}
\begin{latin}
\begin{algorithmic}[1]
\Procedure{BubbleSort}{$A$}
		\State	$ n \gets \attrib{A}{length}$
		\State	$\id{pairs} \gets n-1$
		\State	$\id{swapDone} \gets \const{true}$
		\While{$\id{swapDone} \isequal \const{true}}$
				\State	$\id{swapDone} \gets \const{false}$
				\For{$i \gets 1 \To \id{pairs}$}
						\If{$A[i] > A[i+1]$}
								\State	\bcall{Swap}{$A[i], A[i+1]$}
								\State	$\id{swapDone} \gets \const{true}$
						\EndIf
				\EndFor
				\State	$\id{pairs} \gets \id{pairs}-1$				
		\EndWhile
\EndProcedure
\end{algorithmic}
\end{latin}
\end{algorithm}

با در نظر گرفتن الگوریتم مرتب‌سازی حبابی، مرتبه‌ی زمانی حالات بهترین، متوسط و بدترین را به دست آورید.

\پاسخ

\متن‌سیاه{تحلیل بهترین حالت}

برای تحلیل بهترین حالت باید بررسی کنیم که کمترین تعداد تکرار حلقه‌ها در چه شرایطی روی می‌دهد.  در اولین دور از اجرای حلقه‌ی \lr{while}، حلقه‌ی \lr{for} به طور کامل اجرا شده و {$n-1$} مقایسه انجام می‌شود. در ادامه‌ی اجرای الگوریتم ممکن است دو حالت روی دهد:
\شروع{فقرات}
\فقره به دلیل نامرتب بودن آرایه‌، حداقل یک جابجایی رخ دهد که در این صورت مقدار متغیر {\id{swapDone}} برابر با {\const{true}} شده و سبب می‌شود حلقه‌ی \lr{for} برای حداقل یک دور دیگر نیز اجرا شود. 
\فقره آرایه‌ از قبل به صورت صعودی مرتب باشد که در این صورت مقدار متغیر {\id{swapDone}} برابر با {\const{false}} خواهد ماند و اجرای الگوریتم خاتمه می‌یابد.
\پایان{فقرات}  
به این ترتیب بهترین حالت زمانی رخ می‌دهد که آرایه از قبل به صورت صعودی مرتب باشد که در این حالت تنها {$n-1$} مقایسه انجام می‌شود. پس می‌توان گفت الگوریتم مرتب‌سازی حبابی در بهترین حالت از مرتبه‌ی {$O(n)$} است.

\متن‌سیاه{تحلیل بدترین حالت}

برای تحلیل بدترین حالت باید شرایطی را در نظر بگیریم که تعداد اجرا شدن حلقه‌ها بیشترین تعداد ممکن باشد که در این صورت بیشترین تعداد مقایسات انجام خواهد شد. بدترین حالت در اجرای الگوریتم مرتب‌سازی حبابی زمانی رخ می‌دهد که آرایه به صورت نزولی مرتب باشد. به این ترتیب در گذر اول و در نتیجه‌ی مقایسه خانه‌ی اول (که حاوی بزرگترین مقدار آرایه است) با دیگر خانه‌های آرایه، مقدار خانه‌ی اول تا انتهای آرایه حرکت کرده و در خانه‌ی آخر قرار می‌گیرد. پس از اجرای گذر اول، دومین بزرگترین مقدار در خانه‌ی اول آرایه قرار گرفته است. در گذر دوم، دومین بزرگترین مقدار با تمامی خانه‌های آرایه، به جز خانه‌ی انتهایی، مقایسه شده و در دومین خانه از انتهای آرایه قرار می‌گیرد. این روند به همین ترتیب ادامه می‌یابد و در هر گذر حداکثر تعداد مقایسات انجام می‌شود. به این ترتیب می‌توان گفت برای قرار دادن بزرگترین مقدار در انتهای آرایه به {$n-1$} مقایسه، برای قرار دادن دومین بزرگترین مقدار در خانه‌ی یکی مانده به آخر آرایه به {$n-2$} مقایسه و به همین ترتیب تا {$n$}امین بزرگترین مقدار که به هیچ مقایسه‌ای نیاز ندارد زیرا چنین مقداری خود به خود در مکان درست خود قرار گرفته است. با جمع تعداد کل مقایسات انجام شده داریم:
\begin{displaymath}
W(n)=\sum_{i=1}^{n-1}{i}=\dfrac{n(n-1)}{2}=\dfrac{1}{2}n^2 - \dfrac{1}{2}n=O(n^2)
\end{displaymath}
به این ترتیب نشان دادیم الگوریتم مرتب‌سازی حبابی در بدترین حالت دارای مرتبه‌ی زمانی {$O(n^2)$} است.

\متن‌سیاه{تحلیل حالت متوسط}

فرض می‌کنیم احتمال اینکه در هر گذر دلخواه از الگوریتم، هیچ جابجایی‌ای انجام نشود برابر باهم باشند. با توجه به اینکه این الگوریتم در حالت کلی دارای {$n-1$} گذر است پس احتمال اینکه بعد از یک گذر دلخواه اجرای الگوریتم متوقف شود برابر با {$1/(n-1)$} است. به این ترتیب باید تعداد مقایسات انجام شده بعد از پایان هر یک از این گذرها را به دست آوریم و در احتمال خروج بعد از پایان آن گذر ضرب کنیم. 

اگر اجرای الگوریتم بعد از گذر اول متوقف شود آنگاه دارای {$n-1$} مقایسه خواهیم بود. اگر بعد از گذر دوم اجرای الگوریتم متوقف شود دارای {$(n-1)+(n-2)$} مقایسه خواهیم بود و به همین ترتیب. در ادامه فرض می‌کنیم {$C(i)$} نشان دهنده‌ی تعداد مقایسات بعد از {$i$} گذر باشد. با توجه به اینکه الگوریتم مرتب‌سازی حبابی زمانی متوقف می‌شود که در یک گذر هیچ جابجایی‌ای انجام نشود، باید تمام حالاتی که این الگوریتم امکان توقف دارد را در نظر گرفت. به این ترتیب متوسط تعداد مقایسات از رابطه‌ی {\eqref{ch1:eqn:bubSortAvgCmp}} به دست می‌آید.
\begin{equation}
A(n)=\dfrac{1}{n-1}\sum_{i=1}^{n-1}{C(i)}\label{ch1:eqn:bubSortAvgCmp}
\end{equation}
{$C(i)$} در رابطه‌ی {\eqref{ch1:eqn:bubSortAvgCmp}} برابر است با:
\begin{displaymath}
C(i)=\sum_{j=1}^{i}{(n-j)}=\sum_{j=1}^{i}{n} - \sum_{j=1}^{i}{j}=ni-\dfrac{i(i+1)}{2}=ni - \dfrac{i^2}{2} - \dfrac{i}{2}
\end{displaymath}
با جایگذاری {$C(i)$} در {\eqref{ch1:eqn:bubSortAvgCmp}} به رابطه‌ی {\eqref{ch1:eqn:bubSortAvgCmp1}} می‌رسیم.
\begin{equation}
A(n)=\dfrac{1}{n-1}\sum_{i=1}^{n-1}{\left( ni - \dfrac{i^2}{2} - \dfrac{i}{2} \right) }\label{ch1:eqn:bubSortAvgCmp1}
\end{equation}
می‌توان رابطه‌ی {\eqref{ch1:eqn:bubSortAvgCmp1}} را به صورتی که در ادامه آمده است ساده کرد.

\begin{align*}
A(n) &= \frac{1}{n-1} \left( \sum_{i=1}^{n-1}{ni} - \sum_{i=1}^{n-1}{\frac{i^2}{2}} - \sum_{i=1}^{n-1}{\frac{i}{2}} \right)\\
	 &= \frac{1}{n-1} \left( \frac{n^3-n^2}{2} - \frac{n(n-1)(2n-1)}{12} - \frac{n(n-1)}{4}\right)\\
       &=\dfrac{1}{n-1} \cdot \frac{2n^3-3n^2+n}{6}\\
       &=\dfrac{1}{n-1} \cdot \frac{(2n^2-n)(n-1)}{6}\\
       &=\dfrac{(2n^2-n)(n-1)}{6(n-1)}\\
       &=\dfrac{2n^2-n}{6}\\
       &=\dfrac{1}{3}n^2 -\frac{1}{6}n\\
       &= O(n^2)
\end{align*}
به این ترتیب می‌توان گفت الگوریتم مرتب‌سازی حبابی در حالت متوسط، همچون بدترین حالت، از مرتبه‌ی {$O(n^2)$} است.

\سوال دنباله‌ای از {$n$} عمل بر روی داده‌ساختار {$D$} را در نظر بگیرید. فرض کنید این اعمال را به ترتیب از ۱ تا {$n$} شماره‌گذاری کرده‌ایم. اگر عمل {$i$}ام توانی از دو باشد آنگاه هزینه‌ی این عمل برابر با {$i$} و در غیر اینصورت هزینه‌ی آن برابر با یک خواهد بود. برای مثال اگر دارای دنباله‌ای با چهار عمل باشیم آنگاه هزینه‌ی عمل اول برابر با یک، هزینه‌ی عمل دوم برابر با دو، هزینه‌ی عمل سوم برابر با یک و هزینه‌ی عمل چهارم برابر با چهار خواهد بود و مجموع هزینه‌ی این اعمال برابر با هشت است. با توجه به توضیحات ارائه ‌شده، میانگین هزینه‌ی یک عمل در دنباله‌ای با {$n$} عمل از چه مرتبه‌ای است؟

\پاسخ

در یک دنباله با {$n$} عمل، تعداد اعمالی که شماره‌ی آنها توانی از ۲ است برابر با {$\lfloor \lg n \rfloor +1$} است. اگر این تعداد را از تعداد کل اعمال کم کنیم به تعداد اعمالی می‌رسیم که دارای هزینه‌ی یک هستند. پس تعداد اعمال با هزینه‌ی یک برابر است با {$n-(\lfloor \lg n \rfloor +1)$}. بدین ترتیب می‌توان مجموع هزینه‌ی {$n$} عمل را به صورت زیر به دست آورد:
\begin{align*}
C(n) &= n - \bigl(\lfloor \lg n \rfloor +1\bigr) + \sum_{j=0}^{\lfloor \lg n \rfloor}{2^i}\\
&\leq n -\lfloor \lg n \rfloor -1 + \sum_{j=0}^{\lg n}{2^j}\\
&= n - \lfloor \lg n \rfloor - 1 + 2^{\lg n + 1} - 1\\
&= 2^{\lg n + 1} + n - \lfloor \lg n \rfloor - 2
\end{align*}
با توجه به مقدار به دست آمده برای {$C(n)$} می‌توان گفت {$C(n)=O(2^{\lg n})$}. از طرفی چون می‌دانیم {$2^{\lg n}=n$}  در نتیجه داریم {$C(n)=O(n)$} و این یعنی مجموع هزینه‌ی انجام {$n$} عمل از مرتبه‌ی {$O(n)$} است. به این ترتیب می‌توان گفت میانگین هزینه‌ی انجام یک عمل برابر با {$O(n)/n$} یا همان {$O(1)$} است.